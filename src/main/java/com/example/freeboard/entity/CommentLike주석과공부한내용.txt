// 주석

/**
CommentLike 엔티티
누가 어떤 댓글에 좋아요를 눌렀는지    를  저장하는 엔티티
comment_id와 user_id를 복합 유니크 제약조건으로 설정하여
한 유저가 동일한 댓글에 중복으로 좋아요를 누를 수 없게 만듦
**/
@Entity
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
@Table(
    name = "comment_likes",
    uniqueConstraints = @UniqueConstraint(columnNames = {"comment_id", "user_id"})
    // comment_id + user_id 조합이 유일해야 함 (중복 좋아요 방지)
)
public class CommentLike {

    // 기본 키 (PK)
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)     // AUTO_INCREMENT 전략
    private Long id;

    /**
    좋아요가 눌린 댓글
    다대일 (N:1) 관계 -> 여러 Like가 하나의 Comment에 연결됨
    FetchType.LAZY : 실제 Comment 엔티티는 필요할 때만 불러옴 (성능 최적화)
    OnDelete(CASCADE) : 댓글이 삭제되면 관련된 좋아요도 자동으로 삭제
    **/
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "comment_id", nullable = false)      // 외래 키(FK) 컬럼 이름: comment_id
    @OnDelete(action = OnDeleteAction.CASCADE)
    private Comment comment;

    /**
    좋아요를 누른 사용자
    다대일(N:1) 관계 -> 여러 Like가 하나의 User에 연결됨
    FetchType.LAZY: User 엔티티도 필요할 때만 조회
    OnDelete(CASCADE): 유저가 탈퇴하면 해당 유저의 좋아요 기록도 자동 삭제
    **/
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)     // 외래 키 (FK) 컬럼 이름 : user_id
    @OnDelete(action = OnDeleteAction.CASCADE)
    private User user;
}