이 클래스는 JWT(Json Web Token)을 생성하고, 검증하며, 토큰에서 사용자 정보를 추출하는 핵심역할을 합니다


역할
메서드
설명       // 순서로 기술



비밀키 관리
getSigningKey()
문자열 비밀키 -> HMAC용 SecretKey 객체로 변환

JWT 생성
generateToken()
사용자 정보 + 만료 시간 + 서명 ->
JWT 문자열 생성

JWT 파싱
getUsernameFromJWT()
토큰에서 username(=subject) 추출

JWT 검증
validateToken()
서명, 형식, 만료 여부 등을 체크


이 클래스의 실제 사용 흘므
1. 사용자가 로그인 하면 Authentication 객체가 생성됨
2. generateToken() 이 호출되어 JWT 발급
3. 클라이언트는 JWT를 Authorization: Bearer <token> 헤더로 전송
4. 서버에서는 validateToken() 으로 검증
5. 유효한 경우 getUsernameFromJWT()로 사용자 식별





주석
package com.example.freeboard.security;

/*
JwtTokenProvider
JWT(JSON Web Token)을 생성, 파싱, 검증하는 핵심 유틸리티 클래스입니다.
Spring Security의 Authentication 객체와 연동되어, 인증된 사용자의 토큰을 발급하고 검증합니다.
*/

@Component
// @Component는 스프링(spring)프레임워크에서 빈(Bean)으로 등록하기 위한 어노테이션(Annotation)입니다
// 이 클래스를 스프링이 자동으로 관리하는 객체(Bean)으로 등록해줘!

public class JwtTokenProvider {

    // 로그 출력을 위한 SLF4J Logger
    private static final Logger logger = LoggerFactory.getLogger(JwtTokenProvider.class);



}







public class JwtTokenProvier
이건 자바에서 클래스를 정의하는 선언문입니다.

예를 들어
public class JwtTokenProvider {
    // 클래스의 본문(멤버 변수, 메서드 등)
}

public 
접근 제어자(Access Modifier) - 다른 패키지나 클래스에서도 접근 가능

class
이건 클래스야  라는 선언 키워드

JwtTokenProvider
클래스 이름 - JWT 토큰을 생성하고 검증하는 기능을 담당하는 객체 이름


private static final Logger logger = LoggerFactory.getLogger(JwtTokenProvider.class);
->
이 코드는 
JwtTokenProvier 클래스 안에서 로그를 남기기 위해 logger 객체를 만드는 문장입니다.


Logger 
로그를 찍는 데 사용하는 객체 (SLF4J 인터페이스)

LoggerFactory.getLogger(...)
Logger를 생성해주는 팩토리(공장) 메서드


JwtTokenProvider.class
이 클래스(JwtTokenProvider) 이름으로 로그를 구분하겠다는 뜻

private static final
클래스 전체에서 하나만 쓰이는 고정 객체 (변경 불가능)


이 클래스 (JwtTokenProvider) 안에서 로그를 찍을 때 사용할 로거(logger) 객체를 만든다
라는 뜻

예시
logger.info("JWT 토큰 생성 완료");
logger.error("JWT 검증 실패", e);
이런 식으로 loggger를 이용해 콘솔이나 파일에 로그를 남길 수 있습니다. 

info -> 일반 정보 메시지
error -> 에러 메시지
debug -> 디버깅용 로그




@Value("${app.jwtSecret}")
private String jwtSecret;


@Value
Spring이 설정값을 읽어와서 변수에 넣어주는 어노테이션(주입 도구)



private SecreteKey getSigningKey() {
}

private
이 메서드는 클래스 내부에서만 접근할 수 있다.
외부 클래스나 상속한 클래스에서는 호출 불가능하다
-> 내부 헬퍼 (helper) 용도

SecreteKey
메서드의 반환 타입입니다
이 메서드는 secreteKey 객체를 돌려준다는 뜻입니다



if (this.signingKey == null) {

}

if
조건문 - 조건이 참일 때만 중괄호 {} 안의 코드를 실행함

this.signingKey
현재 객체(this)가 가진 멤버 변수 signingKey 를 의미함

== null
그 변수가 아직 아무 값도 들어 있지 않다 (즉, 초기화 되지 않았다)는 뜻

자연어로 풀면
"현재 signingKey가 아직 만들어지지 않았다면 (=null 이라면) 아래 코드를 실행하라"

즉, 비밀키(SecretKey)가 아직 없으면 새로 생성한다는 의미


전체적인 문맥에서 보면
if (this.signingKey == null) {
    byte[] keyBytes = jwtSecret.getBytes(StandardCharsets.UTF_8);
    this.signingKey = keys.hmacShaKeyFor(keyBytes);
}
"처음 호출될 때만 SecretKey 를 생성하고, 다음엔 재사용하자" 는 구조

이렇게 하는 이유
매번 SecreteKey를 새로 만들면 비효율적이다.
그리고 같은 JWT 서명에 항상 같은 키를 써야 검증이 가능하다
그래서 처음 한번만 만들고(null일 때), 그 뒤엔 이미 저장된 키를 그대로 사용한다.


if(this.signingKey == null)
->
signingKey 가 아직 만들어지지 않았다면 지금 만들어라



byte[] keyBytes = jwtSecret.getBytes(StandardCharsets.UTF_8);

jwtSecret
문자열 형태의 JWT 비밀키(Secret Key) 입니다.

jwtSecret = "mySuperSecretKey123456";
이런 식으로 application.properties 나 application.yml 에서 불러온 문자열입니다.


2. getBytes(StandardCharsets.UTF_8)
문자열을 바이트(byte) 배열로 바꿉니다
UTF-8 인코딩 방식을 사용해서 변환합니다.

즉, "mySuperSecretKey12345" 같은 문자열을
[109,121,83...] 이런 숫자 배열(바이트)로 바꾸는겁니다

3. 바이트로 바꾸는 이유
JWT 서명에 사용할 암호화 키 (SecretKey)는 문자열이 아니라 바이트 배열 형태여야 하기 때문입니다
이 바이트 배열을 기반으로 HMAC 해싱용 키 객체를 만듭니다.

this.signingKey = Keys.hmacShaKeyFor(keyBytes);
이렇게 바이트 배열을 넘겨서 암호화용 키 객체를 만드는 겁니다


this.signingKey = ...

signingKey 는 JwtTokenProvier 클래스 안에 있는 필드입니다.

private SecretKey signingKey;

여기서 this.signingKey = ...는
새로 생성한 비밀키(SecretKey)를 클래스 안에 저장한다는 뜻
(한 번 만들어두면 재사용 하기 위하여)


3. HMAC-SHA 알고리즘이란?
HMAC = Hash-based Message Authentication Code
SHA = Secure Hash Algorithm

JWT 서명할 때 사용하는 해싱 알고리즘입니다
예 : HS256, HS384 HS512


4. 한 줄로 요약하면
JWT 비밀 문자열을 바탕으로 HMAC 서명용 SecretKey 객체를 만드는 코드입니다.



정리
KeyBytes 문자열을 바이트 배열로 바꾼것

keys.hmacShaKeyFor()
HMAC-SHA 용 SecretKey를 저장해둠

this.signingKey
만들어진 SecretKey를 저장해둠

결과 JWT 생성 시 사용할 서명 키 완성




public String generateToken(Authentication authenticaion)


public 
접근 제어자 - 이 메서드는 클래스 밖에서도 호출 가능 하다는 듯

String 반환타입 - 이 메서드가 실행된 후 문자열(String) 값을 반환한다는 뜻

(Authenticaion authenticaion)
Spring Security의 Authentication 객체를 매개변수로 받음.
로그인한 사용자 정보를 담고 있음


Authentication 객체란?
Spring Security에서 현재 인증된 사용자 정보를 담고 있는 핵심 객체입니다



UserDetails userDetails = (UserDetails) authenticaion.getPrincipal();

Authenticaion 객체에서 로그인한 사용자의 정보를 꺼내서 UserDetails 타입으로 변환하는 코드입니다



authenticaion.getPrincipal()
현재 로그인한 사용자의 주체(Principal)를 반환합니다
Spring Security 기본설정에서는 이 값이 UserDetails 객체입니다

즉, UserDetails 안에는 " 사용자의 아이디, 비밀번호, 권한 정보 등 " 이 들어 있습니다


(UserDetails) 형변환
getPrincipal() 메서드는 반환타입이 Object 라서 ,
우리가 UserDetails로 사용하려면 형변환(casting) 해야합니다
그래서 (UserDetails) 를 붙여서 명시적으로 변환하는 것입니다

UserDetails userDetails
UserDetails 는 Spring Security에서 사용자 정보를 표현하기 위한 인터페이스 입니다
우리가 직접 구현한 User엔티티를 기반으로 UserDetails 를 반환하는 경우가 많습니다

UserDetails userDetails = (UserDetails) authenticaion.getPrincipal();


(UserDetails)
반환값을 UserDetails 타입으로 형변환


Date now = new Date();

Date 
java.util.Date 클래스. 날짜와 시간을 표현하는 객체 타입

new Date()
현재 시스템의 날짜와 시간을 담은 새로운 Date 객체 생성

now
생성된 Date 객체를 담는 변수 이름 (보통 "현재 시각"을 의미)


현재 시각을 담은 Date 객체를 만들어서 now 변수에 저장한다.

Date now = new Date();



Date expiryDate = new Date(now.getTime() + jwtExpirationInMs);

현재 시간(now)에 유효시간(jwtExpirationInMs)을 더해서 만료 시각을 구한 다음,
그 값을 새로운 Date 객체로 만든다.

-> 즉, 토큰이 언제 만료되는지 계산하는 코드


Date
java.util.Date 클래스. 날짜와 시간을 표현하는 객체

now.getTime() 
현재 시간을 밀리초(ms) 단위로 변환

jwtExpirationInMs
JWT 만료 시간. 보통 "몇 밀리초 뒤에 만료될지" 를 설정한 값

+ 
현재 시간에 만료 시간(밀리초)을 더함

new Date(...)
계산된 시점을 기반으로 새로운 Date 객체 생성

expiryDate
계산된 시점을 기반으로 새로운 Date 객체 생성

expiryDate 계산된 만료 시간을 담는 변수



Date expiryDate = new Date = new Date(now.getTime() + jwtExpirationInMs);
현재 시간에 만료 기간 (ms 단위)을 더해 만료 시각 계산

now.getTime()
현재 시각을 밀리초로 반환

jwtExpirationInMs
JWT 토큰이 유지될 시간(예 : 3600000 = 1시간)

반환 값
만료 시각을 담은 Date 객체

사용 예
JWT 토큰의 .setExpiration() 값으로 사용




return Jwts.builder()
        .setSubject(userDetails.getUsername())
        .setIssueAt(new Date())
        .setExpiration(expiryDate)
        .signWith(getSigningKey(), SignatureAlgorithm.HS512)
        .compact();

한 줄 요약
사용자 이름을 달고, 발급 시각과 만료 시각을 지정한 뒤,
비밀키로 서명해서 최종적으로 JWT 문자열을 만들어 반환한다

즉,
"사용자의 정보를 기반으로 JWT 토큰을 생성하는 코드" 입니다

Jwts.builder()
JJWT라이브러리의 JWT 생성기(Builder)를 불러옵니다
이 빌더를 통해 토큰에 들어 갈 정보(클레임, 만료시간, 서명 등)를 차례로 설정합니다


.setSubject(UserDetails.getUsername())
JWT의 sub(subject)필드에 사용자 이름을 저장합니다
즉, 토큰의 주인(누구의 토큰인지)을 명시하는 부분입니다

예시 결과 (JWT payload 일부)

json
{
    "sub":"cho_yoosoek"    
}

.setIssuedAt(new Date())
JWT의 발급 시간(iat, issued at)을 현재 시각으로 설정합니다
즉, "이 토큰이 언제 만들어졌는가"를 기록합니다

json
{
    "iat":172545 // UNIX 타임 스탬프
}


.signWith(getSigningKey(), SignatureAlgorithm.HS512)
토큰을 서명(Signature) 하는 부분
두가지 요소를 지정

 
getSigningKey()
비밀키(Secret Key). 서버만 알고 있는 암호화 키

SignatureAlgorithm.HS512 
서명 알고리즘(HMAC SHA-512)
이걸 통해 토큰이 변조되지 않았는지 검증할 수 있습니다.


.compact()
지금까지 설정한 정보를 Base64로 인코딩하고, 실제 JWT 문자열로 압축(compact) 합니다 



정리
Jwts.builder() 
JWT 생성 시작


.setSubject(userDetails.getUsername())
사용자명(토큰 주인) 설정

.setIssuedAt(new Date())
발급 시각 설정

.setExpiration(expiryDate)
만료시각 설정

.signWith(getSigningkey(), SignatureAlgorithm.HS512)
비밀키와 알고리즘으로 서명

.compact()
최종 JWT 문자열 생성

반환값
완성된 JWT 토큰 문자열(String)



public String getUsernameFromJWT(String token)

public 
접근 제어자
어디서든 접근 가능한 공개 메서드임을 의미. (즉, 다른 클래스에서도 호출 가능)

String
메서드의 리턴 타입
즉, 이 메서드는 실행이 끝나면 문자열(String)값을 반환합니다

getUsernameFromJWT
메서드의 이름입니다
"JWT에서 사용자 이름을 가져온다"라는 의미의 이름입니다
(get = 가져오다, Username = 사용자 이름, FromJWT = JWT로부터 )

(String token)
->
메서드의 매개변수(parameter) 부분입니다
token 이라는 이름의 문자열 타입 변수를 입력받습니다.
보통 이 token 은 JWT (JSON Web Token) 형식의 인증 토큰입니다




Claims claims = Jwts.parserBuilder();
JWT를 해석할 파서(parser)를만들기 위해 parserBuilder를 시작하고, 그 결과를 이용해 Claims를 만들 준비를 한다

Claims claims
Claims타입의 변수 이름이 claims 다
->
JWT안의 데이터를 담을 Claims 라는 객체를 선언한다.


Claims란?
JWT의 Payload에 있는 데이터를 나타내는 객체이다

Jwts.parserBuilder()
이 코드는 JWT를 파싱(해석)하기 위한 빌더(Parser Builder)를 생성하는 메서드


Jwts
io.jsonwebtoken.Jwts클래스
JWT를 생성하거나 파싱할 때 사용하는 유틸 클래스

parserBuilder()
JWT를 해석하기 위한 Parser 객체를 만들 준비를 시작한다는 의미
이 단계에서는 아직 파서가 완성된 상태는 아니고,
서명키, 검증 옵션 등을 설정할 수 있는 빌더 단계임

->
JWT 토큰을 해석하고 검증하기 위해, 파서를 만들 준비를 시작한다.


.setSigningKey(getSigningKey())
이 코드는 JWT 파서를 서명 검증용 키와 함께 설정하는 부분

.build()
JWT 파서(Parser)객체를 실제로 완성

.parseClaimsJws(token)
이 한줄은 JWT토큰을 실제로 파싱하고 서명을 검증하는 단계

parseClaimsJws(token)
-> 전달된 token(JWT 문자열)을 해석하고,
서명(Signature)이 유효한지 검증한다.

검증 실패 시 예외(Exception)가 발생하고,
검증 성공 시 ClaimsJws 객체를 반환한다.

.getBody();
파싱된 JWT에서 실제 데이터(payload)를 꺼내는것


return claims.getSubject();
Claims 또는 username(또는 subject)을 꺼내서 반환하는 코드

claims
->
JWT에서 파싱해 꺼낸 본문 데이터(Claims) 객체

getSubject()
->
JWT 표준 필드인 subject(sub)값을 가져오는 메서드
-> 
일반적으로 사용자의 아이디나 username이 들어있음

return
->
메서드 실행 결과로 이 값을 돌려줌



return claims.getSubject();
->
"JWT 안의 subject 값을 읽어서, 메서드 호출자에게 username으로 반환한다"