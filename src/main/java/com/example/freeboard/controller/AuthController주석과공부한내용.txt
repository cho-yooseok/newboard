package com.example.freeboard.controller;

import com.example.freeboard.dto.RegisterRequest; // 회원가입 요청 시 필요한 데이터를 담는 DTO
import com.example.freeboard.dto.AuthRequest; // 로그인 요청 시 필요한 데이터를 담는 DTO
import com.example.freeboard.dto.JwtAuthenticationResponse; // JWT 인증 성공 시 반환할 데이터를 담는 DTO
import com.example.freeboard.dto.UserDto; // 사용자 정보를 담는 DTO


/*
사용자 인증 관련 API를 처리하는 rest 컨트롤러
회원가입 로그인 현재 로그인된 사용자 정보 조회 기능을 제공합니다.
*/
@RestController



public AuthController(UserService userService, AuthenticationManager authenticationManager, JwtTokenProvier tokenProvider) {
}

AuthController 클래스의 생성자(Constructor)  입니다

public AuthController(UserService userService, AuthenticationManager authenticationManager, JwtTokenProvier tokenProvider) {
    this.userService = userService;
    this.authenticationManager = authenticationManager;
    this.tokenProvider = tokenProvider;
}

해석하면
public AuthController(...)
AuthController 객체가 생성될 때 실행되는 생성자.
Spring이 의존성 주입(Dependency Injection, DI)을 통해 필요한 객체들을 자동으로 넣어줌.

UserService userService
사용자 관련 로직(회원가입, 사용자 조회 등)을 담당하는 서비스 클래스

AuthenticationManager authenticationManager
스프링 시큐리티에서 로그인 요청이 들어왔을 때 아이디/비밀번호 검증을 처리하는 객체

JwtTokenProvider tokenProvider
로그인 성공 시 JWT(Json Web Token)를 생성하고 검증하는 역할을 하는 클래스

this.userService = userService;
생성자 파라미터로 받은 userService 를 현재 AuthController 클래스의 필드에 저장

즉, 이 생성자는
AuthController 가 실행될 때, 회원 서비스(UserService), 인증 관리자(AuthenticationManager),
JWT제공자(JwtTokenProvider) 객체를 주입받아 내부에서 사용할 수 있게 설정한다


@Valid
RegisterRequest 객체에 있는 검증 애노테이션(@NotNull, @Size 등)을 검사하여 유효하지 않으면
자동으로 예외 발생

@RequestBody
클라이언트가 HTTP 요청 본문(body)에 담아 보낸 JSON 데이터를 RegisterRequest 객체로 변환해 매핑


RegisterRequest registerRequest
회원가입 요청 데이터를 담는 DTO(Data Transfer Object)
일반적으로 username, password, email 같은 필드가 들어있음


정리
클라이언트가 /api/auth/register 엔드포인트로 회원가입 요청 (JSON 형태)을 보내면,
그 요청을 RegisterRequest 객체로 변환하고, 유효성 검증을 거쳐 처리한 후,
성공 또는 실패 메시지를  ResponseEntity<String> 형태로 반환한다.


userService.registerUser(registerRequest);

userService
회원 관련 기능 (회원가입, 사용자 조회 등)을 담당하는 서비스 클래스 객체

registerUser(...)
UserService 안에 정의된 회원가입 메서드
새로운 사용자를 데이터베이스에 저장하거나, 중복 여부를 확인하는 등의 로직을 수행

registerRequest
클라이언트가 회원가입할 때 보낸 요청 데이터(username, password, email 등이 담긴 DTO)


즉,
회원가입 요청으로 들어온 사용자 정보를 서비스(UserService)에 전달해서 실제 회원가입을 처리한다



ResponseEntity
Spring에서 http 응답(상태코드 + 헤더 + 바디)을 직접 구성할 수 있는 객체

.status(HttpStatus.CREATED)
HTTP 상태 코드를 201 Created 로 설정한다는 의미

보통 리소스가 새로 생성되었을때 (회원가입, 게시글 생성 등) 사용됨

.body("회원가입이 성공적으로 완료되었습니다.!")
응답 본문(body)에 메시지 문자열을 담아서 클라이언트에게 보냄


즉
회원가입이 정상적으로 처리되었으니, 상태 코드 201과 함께 성공 메시지를 응답한다


return ResponseEntity.status(HttpStatus.CREATED).body("회원가입이 성공적으로 완료되었습니다!");


catch
try 블록 안에서 예외(Exception)가 발생했을 때 실행되는 블록

IllegalArgumentException
메서드에 전달된 인자가 잘못되었을 때 발생하는 표준 자바 예외 클래스
예: 사용자 이름이 중복되엇거나, 비밀번호가 유효성 검증을 통과하지 못한 경우

e
발생한 예외 객체를 참조하는 변수

e.getMessage() 등을 통해 예외 메시지를 가져올 수 있음

즉, 이 구문은
만약 회원가입 과정에서 잘못된 인자가 들어와
IllegalArgumentException 예외가 발생하면, 이 블록을 실행한다.

라는 의미이다



return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(e.getMessage());

해석
ResponseEntity
HTTP응답을 직접 제어할 수 있는 객체

.status(HttpStatus.BAD_REQUEST)
HTTP 상태 코드를 400 Bad Request 로 설정

클라이언트가 잘못된 요청을 했을 때 사용됨. (예: 회원가입 시 잘못된 값 전달, 중복된 아이디 등)

.body(e.getMessage())
발생한 예외 객체 e 에서 에러 메시지(getMesssage())를 꺼내서 응답 본문(Body)에 담음
예: "이미 존재하는 사용자 이름입니다." 같은 메시지가 클라이언트에게 전달됨

즉
"잘못된 입력값 때문에 예외가 발생했으니, 상태코드 400과 함께 예외 메시지를 클라이언트에게 전달한다"


catch (Exception e) {
}

catch
try 블록 안에서 예외가 발생했을 때 실행되는 코드 블록

try  블록 안에서 예외가 발생했을 때 실행되는 코드블록

Exception
자바의 모든 예외 클래스의 최상위 부모 클래스
따라서 Exception e 로 받으면 모든 종류의 예외를 처리할 수 있음
RuntimeException, IOException, NullPointerException 등 구체적인 예외들도 다 여기서 잡힙

즉,
앞에서 처리하지 못한 모든 예외(exception)를 잡아서 처리하겠다.


10:30
public ResponseEntity<JwtAuthenticationResponse>
메서드의 반환타입을 의미

ResponseEntity 는 Http 응답(상태코드 + 헤더 + 본문)을 담는 객체이다
제네릭 타입<JwtAuthenticationResopnse>은 응답본문(body)에
JwtAuthenticationResponse 객체를 담는다는 뜻입니다.
즉, 이 메서드는 JWT 인증 결과(토큰 등)를 응답으로 돌려줍니다.

authenticateUser
메서드 이름
사용자 인증을 수행한다는 의미입니다.
보통 로그인 시 아이디/ 비밀번호를 받아 JWT 토큰을 발급하는 역할

@Valid
authRequest 객체에 검증(Validation)을 적용합니다.
예: 아이디/ 비밀번호가 비어있지 않은지, 형식이 맞는지 등을 자동 검사합니다.
검증 실패 시 컨트롤러 메서드까지 오지 않고 예외가 발생합니다.

@RequestBody AuthRequest authRequest
클라이언트가 요청할 때 보낸 JSON 데이터를 자바 객체(AuthRequest)로 변환해 줍니다.

예:
json
{
"username": "user1",
"password": "1234"
}

이런 JSON 이 들어오면 AuthRequest 객체로 바뀌어 authRequest 변수에 담깁니다.

종합해석
이 메서드는 클라이언트가 보낸 로그인 요청(AuthRequest)을 검증한 뒤, 인증이 성공하면
JwtAuthenticationResponse 를 담은 HTTP 응답(ResponseEntity)으로 반환하는 로그인 API 메서드입니다.


Authentication authentication = authenticationManager.authenticate()

Authentication authentication
Spring Security 에서 제공하는 인증 정보 객체를 담는 변수입니다.
로그인 성공 시, 사용자 이름 (username), 권한(authorities), 인증 여부 등을 담게 됩니다.

authenticationManager
Spring Security의 인증을 처리하는 핵심 객체입니다
아이디와 비밀번호를 검사해서 올바른 사용자인지 확인해줍니다.

.authenticate(...)
인증을 수행하는 메서드입니ㅏㄷ.
전달받은 로그인 정보(아이디/ 비밀번호 등)를 확인한 뒤,
인증 성공 시 -> Authentication 객체를 반환
인증 실패 시 -> 예외(BadCredentialsException 등) 발생

authenticationManager.authenticate(...) 는 사용자가 입력한 로그인 정보를 검증해서, 올바른 사용자라면
인증된 Authentication 객체를 반환하는 과정입니다

즉,
"로그인 시도"
인증 매니저가 아이디/ 비밀번호 확인
결과를 authentication 에 담는다

new UsernamePasswordAuthenticationToken()

해석해줘

new UsernamePasswordAuthenticationToken()
UserPasswordAuthenticationToken
Spring Security에서 제공하는 사용자 이름(username) 과 비밀번호(password)를 담는 인증용 객체입니다.

사용자가 로그인할 때 입력한 정보를 이 객체에 담아서 authenticationManager.authenticate() 로 전달합니다.


new UsernamePasswordAuthenticationToken()

UsernamePasswordAuthenticationToken
Spring Security 에서 제공하는 사용자 이름(username)과 비밀번호(password)를 담는 인증용 객체입니다.

사용자가 로그인할 때 입력한 정보를 이 객체에 담아서 authenticationManager.authenticate()로 전달합니다.

생성자 인자
보통 이렇게 사용합니다.

new UsernamePasswordAuthenticationToken(username, password)
username 사용자가 입력한 아이디
password 사용자가 입력한 비밀번호

인증 매니저는 이 토큰 안의 정보를 꺼내 DB에 저장된 값과 비교해 인증을 수행합니다.

반환 결과
처음 생성할 때는 단순히 "아이디/ 비밀번호 만 담긴 토큰"입니다
인증 성공 후에는 Principal(사용자 정보), Authorities(권한 정보) 까지 포함된 완전한 인증 객체로 바뀝니다

new UsernamePasswordAuthenticationToken(...)
사용자가 입력한 아이디와 비밀번호를 담아 인증 매니저에게 전달하기 위한 로그인 요청 토큰입니다.



new UsernamePasswordAuthenticationToken()
authRequest.getUsername(),
authRequest.getPassword()

UsernamePasswordAuthenticationToken 객체를 새로 생성하는 코드입니다.
UsernamePasswordAuthenticationToken
Spring Security 에서 사용자의 인증정보(아이디/비밀번호)를 담는 토큰 클래스입니다.

이 토큰은 AuthenticationManager 로 전달되어 실제 인증 절차(로그인 검증)에 사용됩니다.

authRequest.getPassword()
사용자가 로그인 시 입력한 비밀번호(Password) 값을 꺼내옵니다.

즉, 사용자가 보낸 로그인 요청(authRequest)에서 아이디와 비밀번호를 꺼내어,
Spring Security에서 사용할 인증토큰(UsernamePasswordAuthenticationToken)을 만드는 코드입니다.

정리
사용자가 입력한 아이디와 비밀번호를 기반으로 Spring Security 인증 토큰을 만든다



UserDetails userDetails = (UserDetails)authentication.getPrincipal();

authenticaion
현재 로그인한 사용자의 인증 정보를 담고 있는 객체(Authentication 타입)

getPrincial()
authentication 객체에서 사용자의 주체(Principal) 정보를 가져옴.
여기에는 보통 사용자의 아이디나 계정 정보가 들어있음

(UserDetails)
getPrincipal() 메서드가 반환하는 객체를 UserDetails 타입으로 캐스팅





/*
로그인 요청을 받아서 아이디와 비밀번호를 확인하고,
성공하면 JWT 토큰을 만들어서 돌려주는 기능입니다.

@param authRequest 로그인할 때 보낸 정보(아이디, 비밀번호)
@return JWT 토큰 + 사용자 이름 + 역할(ADMIN/USER)
*/
@PostMapping("/login")
public ResponseEntity<JwtAuthenticationResponse> authenticateUser(@Valid @RequestBody AuthRequest authRequest) {
    // 1. AuthenticationManager()

}

new UsernamePasswordAuthenticationToken(...)
사용자가 보낸 로그인 정보(아이디와 비밀번호)를 담는 인증 토큰 객체를 생성합니다.
여기서는 아직 "검증 전 " 상태입니다.

authenticationManager.authenticate(...)
Spring Security의 AuthenticationManager 를 사용해 아이디와 비밀번호를 실제로 검증합니다.
내부적으로 userDetailsService와 passwordEncoder를 사용해서
아이디가 DB에 존재하는지,
비밀번호가 맞는지 확인합니다.

Authentication authentication = ...
검증이 성공하면, 인증이 완료된 사용자 정보를 담은 Authentication 객체를 반환받아 authentication 변수에 저장합니다.

이 객체 안에는 아이디, 권한(Role), 인증 성공 여부 등의 정보가 들어있습니다.



Authentication authentication = authenticationManager.authenticate(
    new UsernamePasswordAuthenticationToken(
        authRequest.getUsername(),  // 입력한 아이디
        authRequest.getPassword()   // 입력한 비밀번호
    )
);
종합설명
이 한줄은 사용자가 입력한 아이디/비밀번호를 기반으로 로그인 검증을 수행하고,
성공 시 인증된 사용자 정보를 가져오는 과정입니다



// 2. 인증된 사용자 주체(Principal)에서 UserDetails를 가져옵니다.
UserDetails userDetails = (userDetails) authentication.getPrincipal();
String authenticatedUsername = userDetails.getUsername()


해석
authentication.getPrincipal()
Authenticaion 객체에서 주체(Princial) 를 꺼냅니다
"Principal"은 보통 로그인한 사용자 정보를 의미합니다.
Spring Secutiry 에서는 보통 UserDetails 타입으로 반환됩니다.


(UserDetails) authentication.getPrincipal();
getPrincipal() 의 반환타입이 object 라서 ,  UserDetails 로 캐스팅합니다.

UserDetails 는 Spring Security에서 제공하는 사용자 정보 인터페이스(아이디, 비밀번호, 권한 등 을 담음)입니다


userDetails.getUsername();
인증된 사용자 정보에서 아이디(username) 값을 가져옵니다
예를들어, 로그인 시 authRequest.getUsername() 으로 입력받은 아이디가 검증에 성공했다면, 여기서 그 값이 나옵니다

authenticatedUsername
최종적으로 인증된 사용자의 아이디를 문자열 변수에 저장합니다.



UserDetails userDetails = (UserDetails) authentication.getPrincipal();
String authenticatedUsername = userDetails.getUsername();


이 코드는 로그인 검증이 끝난 Authentication 객체에서 사용자 정보를 꺼내고,
그 안에서 인증된 사용자 아이디를 가져오는 과정입니다


// 3. 사용자의 역할(Role) 정보를 가져옵니다.
// Spring Security의 GrantedAuthority에서 첫 번째 역할(ROLE_ADMIN, ROLE_USER 등)을 추출합니다.
String userRole = authentication.getAuthorities().stream()
    .map(GrantedAuthority::getAuthority) // GrantedAuthority 객체에서 권한 문자열을 추출
    .findFirst() // 여러 권한 중 첫 번째를 가져옵니다. (보통 단일 역할일 경우 사용)
    .orElse("ROLE_USER"); // 역할이 없는 경우 기본 값으로 "ROLE_USER" 설정


String userRole = authentication.getAuthorities().stream()
이 부분은 현재 로그인된 사용자(authentication 객체)의 권한(roles/authorities)을 가져와서 스트림으로 변환하는 과정입니다

하나씩 풀어서 설명하면

1. authentication.getAuthorities()
로그인한 사용자의 권한(예 : ROLE_USER, ROLE_ADMIN)을 Collection<GrantedAuthority> 형태로 반환합니다
여러 개의 권한이 있을 수도 있음

2. .stream()
이 권한 리스트를 Java Stream API 로 변환합니다.
이후 .map(), .findFirst(), .collect() 와 같은 스트림 연산을 이어서 권한을 문자열로 꺼내온거나 가공할 수 있ㅅ브니다.

즉, 이 줄은 사용자 권한 목록을 스트림으로 처리하기 시작한다  라는 의미입니다.



.stream()
stream() 은 java stream api 에서 쓰이는 메서드인데,
컬렉션(Collection) -> 스트림(Stream) 으로 바꿔주는 역할을 한다.

쉽게 말하면
List, Set, Collection 같은 자료구조는 단순히 "데이터 묶음"입니다
stream()을 붙이면 이 묶음을 데이터 흐름(파이프라인)으로 바꿔서,
데이터를 필터링, 매핑, 정렬, 집계 등 "연속적인 처리"를 할 수 있게 해줍니다

List<String> names = Arrays.asList("Tom", "Jane", "Mike");

// 그냥 for 문으로 처리
for (String name : names) {
    if (name.startWith("M")) {
        System.out.println(name);
    }
}

// Stream으로 처리
names.stream()
    .filter(name -> name.startWith("M"))
    .forEach(System.out::)



Collection<GrantedAuthority>
Collect
java에서 데이터 묶음을 다루는 가장 기본적인 인터페이스
List, Set 같은 자료구조가 Collection을 상속 받는다
즉, collection 은 데이터 여러 개를 담아 놓을 수 있는 상위 타입


GrantedAuthority
스프링 시큐리티에서 사용자의 권한(Authority)을 표현하는 인터페이스
예: "ROLE_USER", "ROLE_ADMIN" 같은 문자열 권한을 감싸는 객체
실제 구현체는 SimpleGrantedAuthority 가 제일 많이 쓰인다

Collection<GratnedAuthority>
여러 개의 권한(Authority 객체들)을 담아놓은 자료구조   라는 뜻
즉, 사용자가 가지고 있는 모든 권한 리스트


java
[ROLE_USER, ROLE_ADMIN]

만약 이런 권한이 있으면 내부적으로는 이렇게 표현된다

java

Collection<GrantedAuthority> authorities = Arrays.asList(
    new SimpleGrantedAuthority("ROLE_USER"),
    new SimpleGrantedAuthority("ROLE_ADMIN")
);


Collection<GrantedAuthotiry> = "로그인한 사용자의 모든 권한 목록"


authenticaiton.getAuthorities().stream()

authentication.getAuthorities().stream()

authentication.getAuthorities()
현재 로그인한 사용자의 권한 목록을 가져옴
이 권한 목록의 자료형은 Collection<GrantedAutohrity>
(즉, 여러 개의 권한 객체들을 담은 자료구조)

[ROLE_USER, ROLE_ADMIN]


2.
.stream()
이 Collection(권한 묶음)을 Stream(데이터 흐름)으로 바꿔줌
Stream으로 바꾸면 map, filter, forEach, collect 같은 데이터 가공 메서드를 쓸 수 있음.



즉,
authentication.getAuthorities().stream() 은
현재 로그인한 사용자의 권한들을 하나씩 꺼내서 가공할 준비를 한다

String role = authenticaion.getAuthorities().stream()
    .map(GrantedAuthority::getAuthority) // 권한 이름 꺼냄 (예 : "ROLE_USER")
    .findFist()                          // 첫 번째 권한만 가져오기
    .orElse("ROLE_USER");                // 없으면 기본값

    로그인한 사용자의 첫 번째 권한을 role 이라는 문자열로 꺼내는 코드




authentication.getAuthorities() 비유
로그인한 사용자가 가진 권한들을 " 상자 안에 담아둔 상태" 라고 생각해보자
예를 들어, 상자 안에 이렇게 들어있을때

[ROLE_USER, ROLE_ADMIN]

즉, 상자는 Collection<GrantedAuthority> 라는 자료형이다



.stream()
상자 안에 있던 권한들을 줄 세워서 한 명씩 앞으로 나오게 하는 것이다
이제 이 줄은 Stream 이라고 부른다


Stream의 장점
줄을 세웟으니 "앞에서부터 하나씩 써내서 작업"을 할 수 있다.

예를 들어
이름표(권한 이름)만 뽑아내기 -> .map(GrantedAuthority::getAuthority)
특정 조건만 남기기 -> .filter(role -> role.equals("ROLE_ADMIN"))
첫 번째만 가져오기 -> .findFirst()
전부 모아서 다시 리스트 만들기 -> .collect(Collects.toList())



authentication.getAuthoritis().stream()
"로그인한 사용자의 권한들을 상자에서 꺼내 줄 세워놓은 것"
이제 하나씩 꺼내서 가공할 준비가 된 상태



ROLE_USER, ROLE_ADMIN 두 권한을 가지고 있다고 가정


// 로그인된 사용자의 권한 가져오기
Collection<GrantedAuthority> authorities = authentication.getAuthorities();
System.out.println(authorities);


[ROLE_USER, ROLE_ADMIN]

.stream() 으로 줄 세우기

authenticaion.getAuthorities().stream()
    .forEach(authority -> System.out.println(authority));


ROLE_USER
ROLE_AMDIN

상자(Collection)에 있던 권한들이 줄(Stream)으로 세워져서 하나씩 출력됨




GrantedAuthority
스프링 시큐리티에서 권한(Authority)을 표현하는 인터페이스 입니다
즉, 사용자가 어떤 권한을 가지고 있는지 나타내는 객체
simpleGrantedAuthority 라는 구현체를 사용합니다.

GrantedAuthority authority = new SimpleGrantedAuthority("ROLE_USER");


getAuthority()
GrantedAuthority 인터페이스 안에 정의된 메서드
이 메서드는 권한의 이름(문자열)을 반환합니다.


GrantedAuthority authority = new SimpleGrantedAuthority("ROLE_USER");
System.out.println(authority.getAuthority());


.map(GrantedAuthority::getAuthority)의 뜻
스트림 안에 들어있는 GrantedAuthority 객체들에서
getAuthority() 메서드를 호출해서
"ROLE_USER", "ROLE_ADMIN" 같은 문자열 권한 이름만 뽑아온다   는 뜻


GrantedAuthority
권한 객체

getAuthority()
그 권한 객체 안에 들어 있는 문자열(권한 이름)을 꺼내는 메서드



userRole = userRole.substring(5);

substring(int beginIndex)
문자열에서 일부분만 잘라내는 메서드
beginIndex 위치(0부터 시작)에서 끝까지 잘라서 새로운 문자열을 반환합니다


String userRole = "ROLE_USER";
userRole = userRole.substring(5);
System.out.println(userRole);


USER
"ROLE_USER" 에서 앞의 "ROLE_" 부분(0~4 인덱스)을 잘라내고, 5번째 인덱스부터 끝까지 남겨둔 것이다


public Response<UserDto> getLoggedInUserInfo(Authenticaion authenticaion) {

}

public
접근 제어자
어디서든 호출할 수 있는 공개 메서드


ResponseEntity<userDto>
리턴 타입
ResponseEntity 는 스프링에서 HTTP 응답 전체(상태 코드, 헤더, 바디)를 담는 객체.
<UserDto> 는 응답 본문(body)에 담길 데이터 타입이 UserDto 라는 뜻

즉,
UserDto 객체를 HTTP 응답으로 감싸서 반환한다


getLoggedInUserInfo

메서드 이름
직역하면 "로그인한 사용자 정보를 가져온다" 라는 기능을 수행하느 메서드

(Authentication authenticaion)
메서드 파라미터
스프링 시큐리티가 자동으로 현재 로그인한 사용자의 인증정보를 담아서 넣어줌
여기에는 사용자 이름, 권한, 인증 여부 등이 들어있다.




이 메서드는
현재 로그인한 사용자의 인증 정보(authentication)를 받아서, 해당사용자의 정보를 UserDto 형태로 만들어
ResponseEntity 로 반환하는 메서드

즉, REST API 엔드포인트라면 이 메서드는 "내 정보 보기 (마이페이지)" 같은 역할을 하는 것이다.



Optional<User> userOptional = userService.findByUsername(username);

userService.findByUsername(username)
서비스(userService)에서 username을 이용해 사용자(User)를 조회하는 메서드를 호출합니다
반환타입이 Optional<User>이기 때문에, 결과가 있을 수도 있고 없을 수도 있음을 의미합니다.

Optional<User> userOptional
조회 결과를 Optional 로 감싸서 받습니다.
Optional은  null 대신 사용되는 컨테이너 객체로, 값이 있으면 User 객체를 가지고 있고, 없으면 비어 있습니다.

즉, 주어진 사용자 이름으로 사용자 정보를 찾고, 그 결과를 Optional<User>로 저장한다  는 뜻입니다.

원한다면 userOptional 에서 값이 있는지 확인 isPresent(), ifPresent() 하거나, 없을 때 대체값(orElse(), orElseThrow())을
지정해서 처리할 수 있습니다.



Optional<user> userOptional 을 직역하면
Optional<User>
User 객체를 담을 수도 있고, 안 담을 수도 있는 박스    같은 타입

userOptional
그 박스의 변수 이름


userOptional
은 User를 가질 수도 있고(null 일 수도 있음),
안 가질 수도 있는 변수
