주석
/**
JwtAuthenticationFilter
Spring Security의 OncePerRequestFilter를 상속받은 커스텀 필터 클래스.
매 요청마다 실행되며, HTTP 요청 헤더에 포함된 JWT 토큰을 검증하고,
유효한 경우 Spring Security의 인증 컨텍스트(SecurityContext)에 사용자 정보를 설정한다.
**/

@Component // 스프링 빈으로 등록되어 Security Filter Chain에서 사용된다.
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    // 로그 출력을 위한 Logger 인스턴스
    private static final Logger logger = LoggerFanctory.getLogger(JwtAuthenticationFilter.class);

    // JWT 토큰 생성, 검증, 파싱을 담당하는 유틸리티 클래스
    private final JwtTokenProvider tokenProvider;

    // 데이터베이스에서 사용자 정보를 조회하기 위한 서비스
    private final CustomUserDetailsService customUserDetailsService;

    // 생성자 주입(Autowired를 통해 스프링이 의존성을 주입)
    @Autowired
    public JwtAuthenticationFilter(JwtTokenProvider tokenProvier, CustomUserDetailsService customUserDetailsService) {
        this.tokenProvider = tokenProvider;
        this.customUserDetailsService = customUserDetailsService;
    }

    /**
    doFilterInternal
    실제 필터 로직이 수행되는 메서드
    요청(request)에서 JWT를 추출하고, 검증 후 인증 정보를 설정한다.
    **/
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {
        try {
            // 1. 요청 헤더에서 JWT 추출
            String jwt = getJwtFromRequest(request);

            // 2. JWT가 존재하고 유효한 경우
            if(StingUtils.hasText(jwt) && tokenProvider.validateToken(jwt)) {

                // 3. JWT에서 username(또는 email) 추출
                String username = tokenProvider.getUsernameFromJWT(jwt);

                // 4. DB 또는 UserDetailsService에서 해당 사용자 정보 조회
                UserDetails userDetails = customUserDetailsService.loadUserByUsername(username);

                // 5. 스프링 시큐리티의 인증 객체 생성 (비밀번호는 null로 설정)
                UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(
                    userDetails, null, userDetails.getAuthorities());

                // 6. 요청 정보를 Authentication 객체에 추가 (IP, 세션 등)
                authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));

                // 7. SecurityContext에 인증 정보 저장 (현재 스레드의 보안 컨텍스트에 설정)
                SecurityContextHolder.getContext().setAuthentication(authentication);
            }

        } catch (Exception ex) {
            // JWT 검증 실패 시 예외 로그 출력(인증이 실패하더라도 요청은 계속 진행됨)
            logger.error("보안 컨텍스트에 사용자 인증을 설정할 수 없습니다.". ex);
        }

        //  6. 다음 필터로 요청 전달 (다음 시큐리티 필터 또는 컨트롤러로 이동)
        filterChain.doFilter(request, response);
    }

    /**
    getJwtFromRequest
    HTTP 요청 헤더에서 Authorization 값을 추출하고,
    "Bearer" 접두어가 있는 경우 실제 토큰 부분만 반환한다.

    예시:
    Authorization: Bearer eyJhgcfdfkjdkfdfcvdf
    **/
    private String getJwtFromRequest(HttpServletRequest request) {
        // Authorization 헤더 값 가져오기
        String bearerToken = request.getHeader("Authorization");

        // "Bearer"로 시작하는 경우 실제 JWT 부분만 잘라서 반환
        if (StringUtils.hasText(bearerToken) && bearerToken.startsWith("Bearer")) {
            return bearerToken.substring(7);    // "Bearer" 이후의 문자열만 추출
        }

        // 없거나 잘못된 경우 null 반환
        return null;
    }
}




전체 동작 흐름 해설
1. 요청이 들어옴
JwtAuthenticationFilter 가 실행됨(OncePerRequestFilter 를 상속했으므로 요청마다 한 번더 실행됨)

2. 헤더에서 JWT 추출
Authentication: Bearer {JWT} 형식에서 토큰만 분리

3. 토큰 검증
JwtTokenProvider.validateToken(jwt) 호출 (만료 여부, 위조 여부 확인)

4. 사용자 정보 로드
토큰에서 username 추출 후 DB에서 UserDetails 가져옴

5. SecurityCotext에 인증 객체 저장
이후 컨트롤러(@RestController)에서 @AuthenticaitonPrincipal 또는 SecurityContextHolder를 통해
현재 로그인한 사용자 정보 접근 가능.


요약하면, 이 클래스는 모든 요청에 대해 JWT 토큰을 검사하고,
유효하면 Spring Security 인증 컨텍스트에 사용자 정보를 등록하는 역할을 합니다











동작 요약
1. HTTP 요청이 들어오면 이 필터가 실행됨 (OncePerRequestFilter는 요청당 1회 실행 보장)

2. Authorization 헤더에서 "Bearer {JWT}" 형식의 토큰을 추출

3. JwtTokenProvider 를 통해 토큰 검증 (validateToken())

4. 유효하면 토큰에서 사용자명 (username) 추출

5. DB에서 해당 사용자 정보를 로드(CustomUserDetailsService)

6. UsernamePasswordAuthenticationToken 생성 후 보안 컨텍스트에 등록

7. 이후 요청은 인증된 사용자로 처리 가능 (컨트롤러에서 @AuthenticationPrincipal 사용 가능)





@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {
}


@Component
스프링이 이 클래스를 자동으로 빈(Bean)으로 등록하도록 하는 애너테이션입니다
즉, 개발자가 따로 @Bean 설정을 하지 않아도, 스프링이 애플리케이션 실행 시 이 클래스를 스캔해서 스프링 컨테이너에 등록합니다
이로써 의존성 주입 @Autowired 등을 통해 다른 클래스에서 이 필터를 사용할 수 있게 됩니다


public class JwtAuthenticationFilter
JwtAuthenticationFilter는 클래스이름입니다
보통 Jwt(Json Web Token)를 이용해 사용자의 인증정보를 검사하는 보안필터(Security Fitler)역할을 합니다


extends OncePerRequestFilter
OncePerRequestFilter 는 스프링 시큐리티(Spring Security)가 제공하는 추상 클래스입니다
이름 그대로 "요청당 한 번만 실행되는 필터"를 의미합니다
이 클래스를 상속받으면,
매 요청(Request)마다 한 번만 실행되는 doFilterInternal() 메서드를 오버라이드(override)해서 필터 로직을 구현할 수 있습니다


이 코드는 JWT 인증을 처리하기 위한 커스텀 필터 클래스를 정의하는 선언부입니다
스프링이 자동으로 관리하고, 각 HTTP 요청마다 한 번씩 실행되어 JWT 토큰을 검증하는 역할을 하게 됩니다




private static final Logger logger = LoggerFactory.getLogger(JwtAuthenticationFilter.class);


private
접근 제어자로
이 logger 변수는 이 클래스(JwtAuthenticationFilter) 내부에서만 접근 가능합니다


static final
static: 클래스 수준에서 공유되는 변수(객체를 여러 개 만들어도 딱 하나만 존재)
final: 한 번 초기화 되면 변경할 수 없음 (상수처럼 동작)

즉, logger는 공유되고 수정 불가능한 고정된 로거(Logger)입니다


Logger
Logger는 로그를 기록하는 객체타입입니다
주로 코드 실행 중에 발생한 정보, 경고, 오류 메시지를 콘솔이나 파일로 출력할 때 사용됩니다
org.slf4j.Logger 인터페이스에 속합니다


LoggerFactory.getLogger(JwtAuthenticationFilter.class)
LoggerFactory는 로거(Logger)를 생성하는 클래스입니다
getLogger(클래스명.class)를 호출하면, 해당 클래스 전용의 로거를 만들어줍니다
즉, JwtAuthenticationFilter 클래스에서 발생하는 로그를 구분해서 기록할 수 있게 해줍니다

정리하면
이 코드는 JwtAuthenticationFilter 클래스에서 로그를 출력하기 위한 로거(logger)를 정의한 것입니다
실행 중에 "JWT 토큰 검증 실패", "인증 성공"같은 로그 메시지를 남길 때 사용됩니다.


예시
logger.info("JWT 토큰 검증 시작")
logger.error("JWT 토큰이 유효하지 않습니다", e;)

이런 식으로 logger를 이용해 콘솔이나 로그 파일에 메시지를 남길 수 있습니다



private static final Logger logger = LoggwerFactory.getLogger(JwtAuthenticationFilter.class);
->
"로그를 찍기 위한 도구(logger)를 만드는 코드" 입니다


로그(logger)란?
로그는 프로그램이 실행될 때 무슨 일이 일어났는지 기록하는 메시지입니다
예를 들어, 콘솔에 이런걸 남기는 것입니다
->
[INFT] JWT 토큰 확인 시작
[ERROR]  토큰이 유효하지 않습ㅈ니다

이렇게 하면 나중에 문제가 생겼을 때 원인을 찾기 쉽습니다


Logger
로그를 찍는 도구의 타입입니다

LoggerFactory.getLogger(...)
로그 도구(Logger)를 실제로 만들어주는 공장(factory)같은 역할입니다

JwtAuthenticationFilter.class
"이 로그는 JwtAuthenticationFitler 클래스에서 나온 거야"하고 표시해 주는 부분입니다

private static final
프로그램이 실행되는 동안 하나만 만들고 바꾸지 않겠다 라는 뜻입니다





private static final Logger logger = LoggerFactory.getLogger(JwtAuthenticationFilter.class);

결과적으로 이 코드는
JwtAuthenticationFilter 라는 클래스에서 로그를 찍을 수 있는 도구를 하나 만들자



예시
logger.info("JWT 검사 시작!");
// 일반 정보 출력

logger.error("JWT 토큰 오류!");
// 오류 메시지 출력

이렇게 logger를 이용해서 콘솔에 메시지를 찍을 수 있습니다
그럼 개발자가 "아, 여기서 오류가 났구나" 하고 쉽게 알 수 있습니다





private final JwtTokenProvider tokenProvider;
->
"이 클래스 안에서 JWT 토큰을 다루는 도구(tokenProvider)를 사용하겠다"
(그 도구는 JwtTokenProvider 라는 다른 클래스에서 만들어진것입니다)


private
이 변수는 이 클래스 안에서만 사용할 수 있다.
다른 클래스에서는 접근 불가능하다

final
한 번 만들어진 후에는 다시 바꿀 수 없다.
즉, 이 변수는 고정이다

JwtTokenProvider
JWT 토큰을 만들고, 검증하고, 토큰에서 사용자 정보를 꺼내주는 역할을 하는 클래스타입이다

tokenProvier
실제로 그 클래스 객체를 담을 변수 이름이다.
보통 "토큰을 제공하는 도구"라는 뜻으로 이렇게 이름을 짓는다


private final CustomUserDetailsService customUserDertailsService;

CustomUserDetailService 타입의 객체를 customUserDetailsService 라는 이름으로 필드(멤버 변수)로 선언한 코드입니다
이 객체는 사용자 정보를 불러오는 역할을 하는 서비스입니다


private
이 변수는 이 클래스 내부에서만 접근 가능합니다

final
한 번 초기화되면 바꿀 수 없는(재할당 불가)변수입니다

CustomUserDetailsService
사용자 정보를 가져오는 서비스 클래스 (직접 만든 커스텀 클래스)




@Override
protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
    throws ServletException, IOException {
    }



@Override
부모 클래스(또는 인터페이스)의 메서드를 재정의(override) 한다는 뜻
즉, 부모 클래스에 이미 있는 메서드를 내 클래스에서 새롭게 구현하겠다는 의미입니다

여기서는 OncePerRequestFilter 클래스의 doFilterInternal() 메서드를 재정의하고 있습니다


protected
접근 제한자입니다
같은 패키지나, 이 클래스를 상속받은 자식 클래스에서만 접근 가능합니다


void doFilterInternal(...)
doFilterInternal 은 HTTP요청이 들어올 때마다 실행되는 필터의 핵심 메서드입니다
스프링 시큐리티에서는 요청이 들어올 때, 이 메서드 안에서
JWT검증, 인증객체 설정, 로그 출력, 요청 차단 등의 작업을 합니다


매개변수 설명
(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
HttpServletRequest request
-> 클라이언트(브라우저)가 보낸 요청 정보를 담고 있습니다
(예: 헤더, 파라미터, URL 등)

HttpServletResponse response
->
서버가 클라이언트에게 보낼 응답 정보를 담습니다



FilterChain filterChain
->
여러 개의 필터가 순서대로 동작할 때,
다음 필터로 요청을 넘겨주는 역할을 합니다

즉,
filterChain.doFilter(request, response)를 호출하면 다음 필터로 이동합니다


throws ServletException, IOException
메서드 실행 중 서블릿 관련 오류나 입출력 오류가 생길 수 있기 때믄에 이 두 예외를 던질 수 있다는 뜻



정리하면 이 메서드는
->
HTTP 요청이 들어올 때마다 자동으로 호출되어, 필터 로직을 처리하는 메서드
입니다

JWT 인증필터(JwtAuthenticationFilter)라면 보통 여기서
1. 요청 헤더에서 토큰 추출
2. 토큰 유효성 검사
3. 인증 정보(SecurityContext에 저장)
4. 다음 필터로 요청 전달

이런 과정을 수행하게 됩니다


try {
    String jwt = getJwtFromRequest(request);
}


try{...}
에러(예외)가 발생할 수 있는 코드 블록을 감싸는 부분입니다
try 안에서 에러가 생기면 프로그램이 바로 멈추지 않고,
뒤쪽의 catch 블록에서 에러를 처리할 수 있습니다

즉, "이 안의 코드 실행 중에 오류가 날 수도 있으니 대비하자"는 뜻입니다


String jwt = ...
jwt라는 문자열(String) 변수를 선언하고,
그 안에 JWT 토큰 값을 저장한다는 뜻입니다


getJwtFromRequest(request)
request 객체(즉, 사용자의 HTTP 요청)안에서
JWT 토큰을 꺼내오는 메서드입니다

보통 JWT는 클라이언트가 보낼 때 HTTP 헤더에 담겨있습니다

예를들어 이런 형태입니다 ->
Authorization: Bearer eyJhdfjdkksvkldsjfklsdjafksdsdk...



if(...)
조건문입니다
괄호 안의 조건이 true(참) 일 때만 {} 안의 코드를 실행합니다


StringUtils.hasText(jwt)
StringUtils 는 Spring Framework 에서 제공하는 유틸리티 클래스입니다
hasText(String str) 메서드는
문자열이
null 이 아니고,
공백이 아니며,
길이가 0이 아닌 경우
true를 반환합니다


즉,
jwt 라는 문자열이 비어 있지 않다
를 검사하는 부분입니다

StringUtils.hasText("abc")  -> true
StringUtils.hasText("") -> false
StringUtils.hasText("       ") -> false
StringUtils.hasText(null)       -> false



tokenProvider.validateToken(jwt)
tokenProvider는 보통 JWT 관련 기능을 담당하는 클래스입니다
(예 : JwtTokenProvider)

이 메서드는 전달받은 jwt 토큰이
만료되지 않았는지,
서명이 올바른지,
구조가 맞는지
등을 검사해서 유효하면 true, 유효하지 않으면 false를 반환합니다






if (StringUtils.hasText(jwt) && tokenProvider.validateToken(jwt)) {
}

if (...)
조건문입니다
괄호 안의 조건이 true(참)일 때만 {} 안의 코드를 실행합니다

StringUtils.hasText(jwt)

StringUtils는 Spring Framework에서 제공하는 유틸리티 클래스입니다

hasText(String str) 메서드는
문자열이
null이 아니고,
공백이 아니며,
길이가 0이 아닌 경우
-> true를 반환합니다

즉,
jwt 라는 문자열이 비어 있지 않다
를 검사하는 부분입니다

StringUtils.hasText("abc") -> true
StringUtils.hasText("") -> false
StringUtils.hasText("   ") -> false
StringUtils.hasText(null) -> false


tokenProvider.validateToken(jwt)
tokenProvider는 보통 JWT 관련 기능을 담당하는 클래스입니다
(예: jwtTokenProvider)
이 메서드는 전달받은 jwt 토큰이
만료되지 않았는지,
서명이 올바른지,
구조가 맞는지
등을 검사해서 유효하면 true, 유효하지 않으면 false를 반환합니다

즉,
"이 토큰이 진짜인가"
"만료된 건 아닌가?"
를 확인하는 검증단계 입니다


&&(AND 연산자)
양쪽 조건이 모두 true일 때만 전체가 true가 됩니다
즉,
"jwt가 비어 있지 않고, 토큰이 유효한 경우에만 실행해라"
라는 뜻입니다

전체 해석
"요청에서 꺼낸 JWT가 비어있지 않고(hasText(jwt))"
유효한 토큰이면 (validateToken(jwt)),
아래 코드를 실행한다.
->
즉, JWT가 존재하고 올바른 경우에만 인증 과정을 진행하도록 하는 조건문입니다
이 조건이 false면
즉, 토큰이 없거나 잘못된 경우
그냥 다음 필터로 넘어가거나, 인증되지 않은 상태로 처리됩니다





String username = tokenProvider.getUsernameFromJWT(jwt);
이 한줄은 JWT안에 들어 있는 사용자 이름(username)을 꺼내오는 코드입니다

String username = ...
username 이라는 문자열(String) 변수를 선언하고ㅡ
그 안에 값을 저장하겠다는 뜻입니다

즉, 이 코드를 실행하면
username 변수에 토큰 속 사용자 이름이 들어가게 됩니다


tokenProvider
JWT 관련 작업을 담당하는 객체입니다
보통 클래스 이름이 JwtTokenProvider 이고,
토큰을 생성 검증 정보 추출하는 여러 메서드를 가지고 있습니다


getusernameFromJWT(jwt)
전달받은 JWT 문자열(jwt) 안에서
username(사용자 이름 또는 사용자 식별자)을 추출하는 메서드입니다






Stirng username = tokenProvider.getUsernameFromJWT(jwt);
"JWT 토큰 안에서 사용자 이름을 꺼내서 username 변수에 저장한다"




UserDetails userDetails = customUserDetailsService.loadUserByUsername(username);
->
JWT에서 꺼낸 사용자 이름 (username)을 이용해서
그 사용자에 대한 상세 정보(UserDetails)를 불러오는 부분

UserDetails userDetails = customUserDetailsService.loadUserByUsername(username);


UserDetails
UserDetails는 Spring Security에서 제공하는 인터페이스입니다
한마디로 사용자 한 명의 정보 를 담는 객체의 형태를 정의한 것입니다

UserDetails 안에는 이런 정보들이 들어 있습니다

String getUsername();   // 사용자 이름
String getPassword();   // 비밀번호 (암호화된 형태)
Collection<? extends GrantedAuthority> getAuthorities();    // 권한 (ROLE_USER, ROLE_ADMIN) 등

등등

즉, 인증/인가 과정에서 스프링 시큐리티가 필요한 사용자 정보의 표준 형식이다




customUserDetailsService
이건 사용자 정보를 불러오는 서비스 객체입니다
일반적으로 CustomUserDetailsService 클래스는
UserDetailsService 인터페이슬르 구현(implements)해서 만들어집니다

loadUserByUsername(username)
이 메서드는 DB에서 username을 이용해 사용자 정보를 조회하고ㅡ
그 결과를 UserDetails 객체로 만들어 반환합니다


전체 해석
JWT 토큰에서 꺼낸 username으로, 데이터베이스에서 해당 사용자의 정보를  찾아
UserDetails 객체로 가져온다.

JWT에서 사용자 이름을 얻고
DB에서 그 사용자를 조회해
스프링 시큐리티가 이해할 수 있는 형태(UserDetails)로 변환하는 단계입니다

요약
jwt -> username -> userDetails
토큰 속 사용자 -> DB에서 실제 사용자 정보 불러오기

UsernamePsswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(
UsernamePasswordAuthenticationToken
SpringSecurity에서 제공하는 인증 객체(Authentication)의 한 종류입니다
로그인 인증 정보 (사용자, 비밀번호, 권한 등)를 담는 클래스입니다

즉,
이 사용자는 인증된 사용자야
라고 시큐리티에게 알려주는 역할을 합니다

new UsernamePasswordAuthenticationToken(...)
새로운 인증 객체를 생성한다는 뜻입니다
생성자에 들어가는 인자는 보통 다음 세가지 입니다

new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
    principal,      // 사용자 정보(보통 UserDetails)
    credentials,    // 비밀번호 (여기서는 이미 인증되었으므로 null로 둠)
    authorities     // 권한 목록 (ROLE_USER, ROLE_ADMIN)
);




