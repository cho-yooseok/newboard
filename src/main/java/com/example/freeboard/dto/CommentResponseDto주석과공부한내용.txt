해설
1. CommentResponseDto 클래스의 역할
클라이언트(프론트엔드)에게 댓글 데이터를 응답할 때 사용하는 DTO
엔티티(Comment)에서 필요한 데이터만 뽑아내어 전달.

2. Lombok 어노테이션
@Getter, @Setter -> getter/setter 자동 생성
@NoArgsConstructor -> 기본 생성자 생성
@AllArgsConstructor -> 모든 필드를 받는 생성자 생성

3. 생성자 오버로딩
첫 번째 생성자: 좋아요 수 (likeCount)를 서비스 레이어에서 직접 계산해 넣을 때 사용
두 번째 생성자: Comment 엔티티 자체의 likeCount 를 가져옴. 만약 null 이면 기본값 0을 넣음

->
CommentResponseDto는 댓글 ID, 작성자, 작성/수정 시간, 좋아요 수, 좋아요 여부를 포함해
 클라이언트에 반환되는 데이터 모델이다



전체 흐름 정리
1. DB(Comment 엔티티) -> 댓글 원본 데이터 저장
2. Service -> DB에서 댓글 조회 후, 엔티티를 CommentResopnseDto 로 변환
3. Controller -> 변환된 DTO 리스트를 클라이언트(프론트엔드)에 응답



생성자 오버로딩(Constructor Overloading)이란?
-> 같은 클래스 안에서 이름은 같지만 매개변수(파라미터)의 개수나 타입이 다른 생성자를 여러 개 정의하는 것을 말한다

즉, 객체를 만들 때 상황에 따라 다른 방식으로 초기화할 수 있게 해줍니다.

정리
오버로딩(Overloading) = 같은 이름, 다른 매개변수
생성자 오버로딩 = 객체를 다양한 방식으로 초기화할 수 있도록 여러 생성자를 정의하는 것

@NoArgsConstructor -> 기본 생성자 생성
@AllArgsConstructor -> 모든 필드를 받는 생성자 생성




주석
package com.example.freeboard.dto; // DTO 패키지에 속한 클래스

import com.example.freeboard.entity.Comment;    // Comment 엔티티를 불러와 DTO 변환에 사용
import lombok.AllArgsConstructor;               // 모든 필드를 받는 생성자 자동 생성
import lombok.Getter;                           // Getter 메서드 자동 생성
import lombok.NoArgsConstructor                 // 기본 생성자 자동 생성
import lombok.Setter;                           // Setter 메서드 자동 생성

import java.time.LocalDateTime;                 // 날짜/시간 타입 사용


@Getter
@Setter
@NoArgsConstructor                              // 매개변수가 없는 기본 생성자 자동 생성
@AllArgsConstructor                             // 모든 필드를 초기화하는 생성자 자동 생성
public class CommentResponseDto {   // 댓글 응답 데이터를 담는 DTO

    private Long id;                    // 댓글 ID
    private String content;             // 댓글 내용
    private String authorUsername;      // 댓글 작성자 이름
    private LocalDateTime createdAt;    // 댓글 작성 시간
    private LocalDateTime updatedAt;    // 댓글 수정 시간
    private Long likeCount;             // 좋아요 수
    private boolean likedByCurrentUser; // 현재 로그인한 사용자가 좋아요 눌렀는지 여부

    // 생성자 오버로딩 1: Comment 엔티티 + 좋아요 여부 + 좋아요 수를 직접 전달받아 DTO 생성
    public CommentResponseDto(Comment comment, boolean likedByCurrentUser, Long likeCount) {
        this.id = comment.getId();                                      // 엔티티에서 ID 추출
        this.content = comment.getComment();                            // 엔티티에서 댓글 내용 추출
        this.authorUsername = comment.getAuthor().getUsername();        // 작성자 이름 추출
        this.createdAt = comment.getCreatedAt();                        // 작성 시간 추출
        this.updatedAt = comment.getUpdatedAt();                        // 수정 시간 추출
        this.likeCount = likeCount;                                     // 파라미터로 전달받은 좋아요 수 저장
        this.likedByCurrentUser = likedByCurrentUser;                   // 현재 사용자 좋아요 여부 저장
    }

    // 생성자 오버로딩 2: 좋아요 수를 엔티티에서 가져오고, 없으면 기본값 0으로 설정
    public CommentResponseDto(Comment comment, boolean likedByCurrentUser) {
        this.id = comment.getId();                                      // 엔티티에서 ID 추출
        this.content = comment.getContent();                            // 엔티티에서 댓글 내용 추출
        this.authorUsername = comment.getAuthor().getUsername();        //  작성자 이름 추출
        this.createdAt = comment.getCreatedAt();                        // 작성 시간 추출
        this.updatedAt = comment.getUpdatedAt();                        // 수정 시간 추출
        this.likeCount = comment.getLikeCount() != null ? comment.getLikeCount() : 0L;      // null 이면 0
        this.likedByCurrentUser = likedByCurrentUser;                   // 현재 사용자 좋아요 여부 저장
    }
}









==========================================================

@NoArgsConstructor 와 @AllArgsConstructor 는 Lombok 라이브러리 에서 제공하는 어노테이션으로,
개발자가 직접 생성자를 일일이 만들지 않아도 자동으로 생성해주는 기능이다

1. @NoArgsConstructor
뜻 : 매개변수가 없는 기본 생성자를 자동으로 만들어줌
즉, new 클래스명() 형태로 객체를 만들 수 있게 해줌

예제 코드
import lombok.NoArgsConstructor;

@NoArgsConstructor // 기본 생성자 자동 생성
public class User {
    private String name;
    private int age;
}

// 위 어노테이션이 붙으면 컴파일 시 아래 코드가 자동으로 추가됨
// public User() {}


사용 예시
public class Main
    public ststic void main(String[] args) {
        User user = new User();     // 기본 생성자 호출 가능
        // user.setName("철수");
        // user.setAge(20);
    }
}


2. @AllArgsConstructor
뜻 : 모든 필드를 매개변수로 받는 생성자를 자동으로 만들어 줌
즉, 객체를 만들 때 값을 한 번에 넣을 수 있음

예제 코드
import lombok.AllArgsConstructor;

@AllArgsConstructor // 모든 필드를 받는 생성자 자동 생성
public class User {
    private String name;
    private int age;
}

    // 위 어노테이션이 붙으면 컴파일 시 아래 코드가 자동으로 추가됨
    // public User(String name, int age) {
    //   this.name = name;
    //   this.age = age;
    // }


사용 예시
public class Main
    public static void main(String[] age) {
        User user = new User ("철수", 20); // 모든 필드 값을 넣어 생성 가능
    }


정리
@NoArgsConstructor
아무것도 안 받는 생성자 자동 생성

@AllArgsConstructor
모든 필드를 받는 생성자 자동 생성

실무에서는 두 개를 함께 사용하는 경우도 많다
예를 들어 JPA(Entity 클래스)는 기본 생성자가 꼭 필요해서 @NoArgsConstructor 를, DTO 나 VO 같은 경우는
한 번에 값을 넣기 위해 @AllArgsConstructor  를 씁니다


3. @RequiredArgsConstructor
뜻 : final 이거나 @NonNull 이 붙은 필드만을 매개변수로 받는 생성자를 자동 생성해줌
즉, 꼭 필요한 필드들만 생성자 파라미터로 받게 해줌

예제 코드
import lombok.RequiredArgsConstructor;
import lombok.NonNull'

@RequiredArgsConstructor
public class User {
    private final String name;      // final -> 반드시 생성 시 필요
    @NonNull
    private String eamil;           // @NonNull -> 반드시 생성 시 필요
    private int age;                // 선택 사항
}

    // 위 어노테이션이 붙으면 자동으로 이런 생성자가 추가됨
    // public User(Stirng name, String email) {
    //      this.name = name;
    //      this.email. = email;
    // }


사용 예시
public class Main {
    public static void main(String[] args) {
        User user = new User("철수", "chulsu@email.com");
        // age는 생성자에 없음 -> 필요하면 setter로 나중에 넣을 수 있음
    }
}

정리 (세 가지 차이점)
@NoArgsConstructor
-> 아무 것도 안 받는 생성자
-> new User()

@AllArgsConstructor
-> 모든 필드를 받는 생성자
-> new User("철수", 20, "email@...")

@RequiredArgsConstructor
-> final 또는 @NonNull 필드만 받는 생성자
-> new User("철수", "email@...")


실무에서는 보통 이렇게 씁니다
Entity(JPA)
-> @NoArgsConstructor (기본 생성자 필수) + @RequiredArgsConstructor (필수값만 받도록)

DTO
-> @AllArgsConstructor (필드 전체를 한 번에 세팅)



예제 코드 : JPA 엔티티
java

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import lombok.*;

@Entity
@Getter
@NoArgsConstructor          // JPA에서 프록시 생성을 위해 반드시 필요
@AllArgsConstructor         // 모든 필드를 받는 생성자
@RequiredArgsConstructor    // final, @NonNull 필드만 받는 생성자
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;    // DB에서 자동 생성 -> 생성자에서 제외하는 경우 많음

    @NonNull
    private String username; // 반드시 필요

    @NonNull
    private String email; // 반드시 필요

    private int age; // 선택 사항
}


생성자 사용 방법

java
public class Main
    public static void main(String[] args) {

        // 1. @NoArgsConstructor -> 기본 생성자
        User user1 = new User();
        // user1.setUsername("철수");     // setter나 다른 방식으로 값 설정
        // user1.setEmail("test@test.com");

        // 2. @AllArgsConstructor -> 모든 필드 받는 생성자
        User user2 = new User(1L, "영희", "younghee@test.com", 25);

        // 3. @RequiredArgsConstructor -> 필수값(final, @NonNull)만 받는 생성자
        User user3 = new User("민수", "minsu@test.com");
    }
}



정리
@NoArgsConstructor -> JPA에서 필수 (프록시, 리플렉션 때문에 기본 생성자 필요)
@AllArgsConstructor -> DTO 변환 같은 경우에 유용 (모든 값 한 번에 세팅)
@RequiredArgsConstructor -> 필수 필드만 강제할 때 유용




1. JPA와 프록시(Proxy)란?
프록시 객체 : JPA 가 엔티티를 실제로 DB에서 가져오지 않고, "가짜 객체"를 먼저 만들어서 대신 사용하는 기술
예를 들어 @ManyToOne, @OneToMany 같은 연관관계에서 지연로딩(Lazy Loading)을 할 때 자주 쓰인다

즉, JPA 는 실제 DB에서 값을 가져오기 전까지는 임시 대리 객체(Proxy)를 생성해둡니다.


2. 왜 기본 생성자가 필요할까?
프록시 객체를 만들 때 JPA는 리플렉션(Reflection)을 사용합니다.
리플렉션 = 코드에서 클래스를 보고 자동으로 객체 생성하거나 필드 값을 변경하는 기능
그런데 이때 기본 생성자(매개변수 없는 생성자)가 없으면 객체를 만들 수가 없습니다.

예시 상황

java

@Entity
public class User {
    @Id
    private Long id;
    private String name;

    // 기본 생성자가 없으면 -> JPA가 프록시를 만들 수 없음

}



3. 정리
실제 객체 = 진짜 "User" (DB에 저장된 값 다 들고 있음)
프록시 객체 = "빈 껍데기 User" (DB값 아직 없음, 필요할 때 불러옴)

프록시 객체를 만들려면 일단 껍데기라도 만들어야 하니까  -> JPA는 "매개변수 없는 생성자"를 필요로 한다


4. 그래서 JPA 엔티티 규칙
@Entity 클래스에는 반드시 기본 생성자가 있어야 한다
public 또는 protected 으로 두는 게 권장된다 (외부에서 막 쓰지 못하게 protected 많이 쓴다)

예제
java

@Entity
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED) // 외부에서 함부로 못 쓰도록
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String username;

    // 필요하다면 다른 생성자들 추가
    public User(String username) {
        this.username = username;
    }
}



최종 정리
JPA 는 엔티티를 DB에서 가져오거나 프록시를 만들 때 리플렉션을 통해 객체 생성을 합니다.
이때 매개변수 없는 기본 생성자가 꼭 필요하기 때문에 @NoArgsConstructor 를 달아줍니다.




"필요하면 setter로 나중에 넣을 수 있음"   의 의미
->
생성자에서 값을 넣지 않아도, 객체를 만든 후 setter 메서드를 이용해서 값을 나중에 설정할 수 있다는 뜻

예시코드
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@RequiredArgsConstructor // final, @NonNull 필드만 받는 생성자 생성
public class User {
    private final String username;      // 반드시 필요 (생성자에서만 초기화)
    private String email;               // 나중에 setter로 값 변경 가능
    private int age;                    // 나중에 setter로 값 변경 가능
}


사용 방법
public class Main {
    public static void main(String[] args) {
        // 생성자에서 username 만 넣음 (필수값)
        User user = new User("철수");

        // 나머지 필드(email, age)는 setter로 나중에 설정 가능
        user.setEmail("chulsoo@test.com");
        user.setAge(20);

        System.out.println(user.getUsername());     // 철수
        System.out.println(user.getEmail());        // chulsoo@test.com
        System.out.println(user.getAge());          // 20
    }
}


정리
final 또는 @NonNull 필드는 @RequiredArgsConstructor 생성자로 반드시 넣어야 함
final 이 아닌 필드는 setter 메서드를 이용해 객체 생성 후 나중에 값 설정 가능

즉 "필수값은 생성자에서 보장" + "선택값은 setter로 나중에 변경"이라는 유연한 방식을 만들 수 있다.



프록시

1. 프록시(Proxy)
대리인, 가짜 객체라고 생각하면 된다.
JPA는 엔티티를 가져올 때 바로 DB에서 모든 값을 가져오지 않고, 대신 껍데기 객체(프록시)를 먼저 만들어 둡니다.

왜? 성능때문입니다!

예를 들어 @ManyToOne  같은 연관관계에서 항상 모든 데이터를 가져오면 너무 무겁기 때문에
필요할 때만 실제 DB조회를 하기 위해 프록시를 씁니다.


비유하자면
프록시 = "대리인"
네가 어떤 친구를 만나러 갔는데, 그 친구가 아직 안 와서 대신 친구 동생이 "형 곧 올거야" 라고 말해주는 느낌
나중에 진짜 친구가 오면 그제서야 실제 데이터를 가져오는 것 = 지연 로딩(Lazy Loading)



