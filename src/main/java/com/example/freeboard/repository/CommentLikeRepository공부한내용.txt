CommentLikeRepository는 댓글 좋아요 기능을 다루는 DB 접근 계층으로, 좋아요 조회/확인/삭제를 담당한다.


package com.example.freeboard.repository;

import com.example.freeboard.entity.Comment;
import com.example.freeboard.entity.CommentLike;
import com.example.freeboard.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

import java.util.Optional;

@Repository // 스프링에게 이 인터페이스가 "DB 접근 계층(Repository)"임을 알림
public interface CommentLikeRepository extends JpaRepository<CommentLike, Long> {
    // CommentLike 엔티티를 기본적으로 CRUD할 수 있는 Repository
    // JpaRepository<CommentLike, Long> → (엔티티, PK 타입)

    // === 특정 댓글과 특정 사용자의 좋아요 찾기 ===
    Optional<CommentLike> findByCommentAndUser(Comment comment, User user);
    // - 댓글과 사용자 정보를 함께 전달받아, 그 조합으로 좋아요가 존재하는지 조회
    // - 결과가 없을 수도 있으므로 Optional로 반환

    //**
    Optional<CommentLike> findByCommentAndUser(Comment comment, User user);
    해석
    Optional<CommentLike>
    → 결과가 있을 수도 있고 없을 수도 있으므로 Optional로 감싸 반환.
    → 존재하면 CommentLike 객체를 담고, 없으면 Optional.empty() 반환.

    findByCommentAndUser
    → 스프링 데이터 JPA의 메서드 이름 규칙에 따라 자동으로 쿼리가 만들어짐.
    → “comment와 user 조건에 맞는 CommentLike를 찾는다”라는 의미.

    매개변수
    Comment comment → 특정 댓글
    User user → 특정 사용자
    즉, "특정 댓글에 대해 특정 사용자가 누른 좋아요(CommentLike)가 있는지 조회한다"라는 뜻입니다.

    **//

    // === 특정 댓글과 특정 사용자의 좋아요 여부 확인 ===
    boolean existsByCommentAndUser(Comment comment, User user);
    // - 해당 댓글에 대해 사용자가 좋아요를 눌렀는지 여부만 true/false로 확인 가능

    // === 특정 사용자가 누른 모든 좋아요 삭제 ===
    @Transactional    // DB 트랜잭션 안에서 실행
    @Modifying        // SELECT가 아닌 변경/삭제 쿼리임을 명시
    void deleteByUser(User user);
    // - 특정 사용자가 계정을 삭제하거나 탈퇴했을 때, 그 사용자가 누른 모든 좋아요 기록을 삭제
}




추가 해설
JpaRepository<CommentLike, Long>
CommentLike 엔티티를 관리하는 JPA Repository
Long은 CommentLike 엔티티의 PK 타입

findByCommentAndUser
댓글과 사용자 기준으로 특정 좋아요를 찾음
Optional 반환 → 값이 없을 수도 있음

existsByCommentAndUser
특정 댓글에 대해 사용자가 이미 좋아요를 눌렀는지 빠르게 확인
boolean 반환

deleteByUser
사용자(User)가 탈퇴하면 그 사용자가 누른 좋아요 기록도 함께 삭제
@Modifying + @Transactional 붙여야 DML(DELETE) 실행 가능





Optional<CommentLike>findByCommentAndUser(Comment comment, User user);

Optional<CommentLike>
결과가 있을 수도 있고 없을 수도 있으므로 Optional로 감싸 반환
존재하면 CommentLike 객체를 담고, 없으면 Optional.empty() 반환

findByCommentAndUser
스프링 데이터 JPA의 메서드 이름 규칙에 따라 자동으로 쿼리가 만들어짐
comment와 user 조건에 맞는 CommentLike를 찾는다 라는 의미


Comment comment -> 특정 댓글
User user -> 특정 사용자

-> 즉, 특정 댓글에 대해 특정 사용자가 누른 좋아요(CommentLike) 가 있는지 조회한다
라는 뜻


Optional<CommentLike> findByCommentAndUser(Comment comment, User user);
->
댓글과 사용자 정보를 조건으로 해당 좋아요를 찾아 Optional 로 반환한다




boolean existsByCommentAndUser(Comment comment, User user);

boolean existsByCommentAndUser(Comment comment, User user);
해석
boolean
->
결과가 true 또는 false로 반환됨

existsByCommentAndUser
->
스프링 데이터 JPA 네이밍 규칙에 따라 자동으로 쿼리 생성
-> comment와 user 조건에 맞는 CommentLike 레코드가 존재하는지 여부를 확인

매개변수
Comment comment -> 특정 댓글
User user -> 특정 사용자

특정 댓글에 대해 해당 사용자가 이미 좋아요를 눌렀는지 여부를 true/ false로 반환한다

예시
boolean liked = commentLikeRepository.existsByCommentAndUser(comment, user);

if(liked) {
    System.out.println("이미 좋아요 했습니다.")
} else {
    System.out.println("아직 좋아요하지 않았습니다")
}





@Transactional
@Modifying
void deleteByUser(User user);


@Transactional
-> 이 메서드는 트랜잭션 안에서 실행됨
-> 데이터베이스 작업(삭제)이 중간에 실패하면 전체 작업을 롤백.

@Modifying
-> 이 메서드가 데이터 변경(DML: INSERT, UPDATE, DELETE) 작업임을 명시
-> JPA 기본 메서드는 SELECT 용이므로, 수정/삭제할 때 반드시 붙여야 함


void deleteByUser(User user)
-> 스프링 데이터 JPA 네이밍 규칙에 따라 자동으로 쿼리 생성
-> 특정 User 와 관련된 모든 CommentLike 데이터를 삭제
-> 반환 타입이 void 라서 삭제 개수는 반환하지 않음

-> 특정 사용자가 누른 모든 댓글 좋아요 기록을 삭제한다

즉, 이 메서드는 사용자 탈퇴 시, 해당 사용자가 누른 모든 좋아요를 정리(clean-up) 하는 데 사용됩니다


