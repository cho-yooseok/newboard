주석
/**
JwtAuthenticationFilter
Spring Security의 OncePerRequestFilter를 상속받은 커스텀 필터 클래스.
매 요청마다 실행되며, HTTP 요청 헤더에 포함된 JWT 토큰을 검증하고,
유효한 경우 Spring Security의 인증 컨텍스트(SecurityContext)에 사용자 정보를 설정한다.
**/

@Component // 스프링 빈으로 등록되어 Security Filter Chain에서 사용된다.
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    // 로그 출력을 위한 Logger 인스턴스
    private static final Logger logger = LoggerFanctory.getLogger(JwtAuthenticationFilter.class);

    // JWT 토큰 생성, 검증, 파싱을 담당하는 유틸리티 클래스
    private final JwtTokenProvider tokenProvider;

    // 데이터베이스에서 사용자 정보를 조회하기 위한 서비스
    private final CustomUserDetailsService customUserDetailsService;

    // 생성자 주입(Autowired를 통해 스프링이 의존성을 주입)
    @Autowired
    public JwtAuthenticationFilter(JwtTokenProvider tokenProvier, CustomUserDetailsService customUserDetailsService) {
        this.tokenProvider = tokenProvider;
        this.customUserDetailsService = customUserDetailsService;
    }

    /**
    doFilterInternal
    실제 필터 로직이 수행되는 메서드
    요청(request)에서 JWT를 추출하고, 검증 후 인증 정보를 설정한다.
    **/
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {
        try {
            // 1. 요청 헤더에서 JWT 추출
            String jwt = getJwtFromRequest(request);

            // 2. JWT가 존재하고 유효한 경우
            if(StingUtils.hasText(jwt) && tokenProvider.validateToken(jwt)) {

                // 3. JWT에서 username(또는 email) 추출
                String username = tokenProvider.getUsernameFromJWT(jwt);

                // 4. DB 또는 UserDetailsService에서 해당 사용자 정보 조회
                UserDetails userDetails = customUserDetailsService.loadUserByUsername(username);

                // 5. 스프링 시큐리티의 인증 객체 생성 (비밀번호는 null로 설정)
                UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(
                    userDetails, null, userDetails.getAuthorities());

                // 6. 요청 정보를 Authentication 객체에 추가 (IP, 세션 등)
                authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));

                // 7. SecurityContext에 인증 정보 저장 (현재 스레드의 보안 컨텍스트에 설정)
                SecurityContextHolder.getContext().setAuthentication(authentication);
            }

        } catch (Exception ex) {
            // JWT 검증 실패 시 예외 로그 출력(인증이 실패하더라도 요청은 계속 진행됨)
            logger.error("보안 컨텍스트에 사용자 인증을 설정할 수 없습니다.". ex);
        }

        //  6. 다음 필터로 요청 전달 (다음 시큐리티 필터 또는 컨트롤러로 이동)
        filterChain.doFilter(request, response);
    }

    /**
    getJwtFromRequest
    HTTP 요청 헤더에서 Authorization 값을 추출하고,
    "Bearer" 접두어가 있는 경우 실제 토큰 부분만 반환한다.

    예시:
    Authorization: Bearer eyJhgcfdfkjdkfdfcvdf
    **/
    private String getJwtFromRequest(HttpServletRequest request) {
        // Authorization 헤더 값 가져오기
        String bearerToken = request.getHeader("Authorization");

        // "Bearer"로 시작하는 경우 실제 JWT 부분만 잘라서 반환
        if (StringUtils.hasText(bearerToken) && bearerToken.startsWith("Bearer")) {
            return bearerToken.substring(7);    // "Bearer" 이후의 문자열만 추출
        }

        // 없거나 잘못된 경우 null 반환
        return null;
    }
}




전체 동작 흐름 해설
1. 요청이 들어옴
JwtAuthenticationFilter 가 실행됨(OncePerRequestFilter 를 상속했으므로 요청마다 한 번더 실행됨)

2. 헤더에서 JWT 추출
Authentication: Bearer {JWT} 형식에서 토큰만 분리

3. 토큰 검증
JwtTokenProvider.validateToken(jwt) 호출 (만료 여부, 위조 여부 확인)

4. 사용자 정보 로드
토큰에서 username 추출 후 DB에서 UserDetails 가져옴

5. SecurityCotext에 인증 객체 저장
이후 컨트롤러(@RestController)에서 @AuthenticaitonPrincipal 또는 SecurityContextHolder를 통해
현재 로그인한 사용자 정보 접근 가능.


요약하면, 이 클래스는 모든 요청에 대해 JWT 토큰을 검사하고,
유효하면 Spring Security 인증 컨텍스트에 사용자 정보를 등록하는 역할을 합니다











동작 요약
1. HTTP 요청이 들어오면 이 필터가 실행됨 (OncePerRequestFilter는 요청당 1회 실행 보장)

2. Authorization 헤더에서 "Bearer {JWT}" 형식의 토큰을 추출

3. JwtTokenProvider 를 통해 토큰 검증 (validateToken())

4. 유효하면 토큰에서 사용자명 (username) 추출

5. DB에서 해당 사용자 정보를 로드(CustomUserDetailsService)

6. UsernamePasswordAuthenticationToken 생성 후 보안 컨텍스트에 등록

7. 이후 요청은 인증된 사용자로 처리 가능 (컨트롤러에서 @AuthenticationPrincipal 사용 가능)





@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {
}


@Component
스프링이 이 클래스를 자동으로 빈(Bean)으로 등록하도록 하는 애너테이션입니다
즉, 개발자가 따로 @Bean 설정을 하지 않아도, 스프링이 애플리케이션 실행 시 이 클래스를 스캔해서 스프링 컨테이너에 등록합니다
이로써 의존성 주입 @Autowired 등을 통해 다른 클래스에서 이 필터를 사용할 수 있게 됩니다


public class JwtAuthenticationFilter
JwtAuthenticationFilter는 클래스이름입니다
보통 Jwt(Json Web Token)를 이용해 사용자의 인증정보를 검사하는 보안필터(Security Fitler)역할을 합니다


extends OncePerRequestFilter
OncePerRequestFilter 는 스프링 시큐리티(Spring Security)가 제공하는 추상 클래스입니다
이름 그대로 "요청당 한 번만 실행되는 필터"를 의미합니다
이 클래스를 상속받으면,
매 요청(Request)마다 한 번만 실행되는 doFilterInternal() 메서드를 오버라이드(override)해서 필터 로직을 구현할 수 있습니다


이 코드는 JWT 인증을 처리하기 위한 커스텀 필터 클래스를 정의하는 선언부입니다
스프링이 자동으로 관리하고, 각 HTTP 요청마다 한 번씩 실행되어 JWT 토큰을 검증하는 역할을 하게 됩니다




private static final Logger logger = LoggerFactory.getLogger(JwtAuthenticationFilter.class);


private
접근 제어자로
이 logger 변수는 이 클래스(JwtAuthenticationFilter) 내부에서만 접근 가능합니다


static final
static: 클래스 수준에서 공유되는 변수(객체를 여러 개 만들어도 딱 하나만 존재)
final: 한 번 초기화 되면 변경할 수 없음 (상수처럼 동작)

즉, logger는 공유되고 수정 불가능한 고정된 로거(Logger)입니다


Logger
Logger는 로그를 기록하는 객체타입입니다
주로 코드 실행 중에 발생한 정보, 경고, 오류 메시지를 콘솔이나 파일로 출력할 때 사용됩니다
org.slf4j.Logger 인터페이스에 속합니다


LoggerFactory.getLogger(JwtAuthenticationFilter.class)
LoggerFactory는 로거(Logger)를 생성하는 클래스입니다
getLogger(클래스명.class)를 호출하면, 해당 클래스 전용의 로거를 만들어줍니다
즉, JwtAuthenticationFilter 클래스에서 발생하는 로그를 구분해서 기록할 수 있게 해줍니다

정리하면
이 코드는 JwtAuthenticationFilter 클래스에서 로그를 출력하기 위한 로거(logger)를 정의한 것입니다
실행 중에 "JWT 토큰 검증 실패", "인증 성공"같은 로그 메시지를 남길 때 사용됩니다.


예시
logger.info("JWT 토큰 검증 시작")
logger.error("JWT 토큰이 유효하지 않습니다", e;)

이런 식으로 logger를 이용해 콘솔이나 로그 파일에 메시지를 남길 수 있습니다



private static final Logger logger = LoggwerFactory.getLogger(JwtAuthenticationFilter.class);
->
"로그를 찍기 위한 도구(logger)를 만드는 코드" 입니다


로그(logger)란?
로그는 프로그램이 실행될 때 무슨 일이 일어났는지 기록하는 메시지입니다
예를 들어, 콘솔에 이런걸 남기는 것입니다
->
[INFT] JWT 토큰 확인 시작
[ERROR]  토큰이 유효하지 않습ㅈ니다

이렇게 하면 나중에 문제가 생겼을 때 원인을 찾기 쉽습니다


Logger
로그를 찍는 도구의 타입입니다

LoggerFactory.getLogger(...)
로그 도구(Logger)를 실제로 만들어주는 공장(factory)같은 역할입니다

JwtAuthenticationFilter.class
"이 로그는 JwtAuthenticationFitler 클래스에서 나온 거야"하고 표시해 주는 부분입니다

private static final
프로그램이 실행되는 동안 하나만 만들고 바꾸지 않겠다 라는 뜻입니다





private static final Logger logger = LoggerFactory.getLogger(JwtAuthenticationFilter.class);

결과적으로 이 코드는
JwtAuthenticationFilter 라는 클래스에서 로그를 찍을 수 있는 도구를 하나 만들자



예시
logger.info("JWT 검사 시작!");
// 일반 정보 출력

logger.error("JWT 토큰 오류!");
// 오류 메시지 출력

이렇게 logger를 이용해서 콘솔에 메시지를 찍을 수 있습니다
그럼 개발자가 "아, 여기서 오류가 났구나" 하고 쉽게 알 수 있습니다





private final JwtTokenProvider tokenProvider;
->
"이 클래스 안에서 JWT 토큰을 다루는 도구(tokenProvider)를 사용하겠다"
(그 도구는 JwtTokenProvider 라는 다른 클래스에서 만들어진것입니다)


private
이 변수는 이 클래스 안에서만 사용할 수 있다.
다른 클래스에서는 접근 불가능하다

final
한 번 만들어진 후에는 다시 바꿀 수 없다.
즉, 이 변수는 고정이다

JwtTokenProvider
JWT 토큰을 만들고, 검증하고, 토큰에서 사용자 정보를 꺼내주는 역할을 하는 클래스타입이다

tokenProvier
실제로 그 클래스 객체를 담을 변수 이름이다.
보통 "토큰을 제공하는 도구"라는 뜻으로 이렇게 이름을 짓는다
