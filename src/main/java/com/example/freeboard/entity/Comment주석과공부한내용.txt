주석
package com.example.freeboard.entity;

import com.fasterxml.jackson.annotation.JsonBackReference;
import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructoer;
import org.hibernate.annotation.OnDelete;        // JPA에서 지원하지 않는 DB레벨의 삭제 동작을 제어하기 위해 Hibernate 제공
import org.hibernate.annotations.OnDeleteAction; // OnDelete 에서 사용되는 삭제 옵션 (CASCADE 등)

import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.Set;

@Entity     // JPA 엔티티임을 명시 -> 테이블과 매핑됨
@Getter     // Lombok: 모든 필드에 대해 Getter 자동 생성
@Setter     // Lombok: 모든 필드에 대해 Setter 자동 생성
@NoArgsConstructor // Lombok: 기본 생성자 자동 생성
@AllArgsConstructor // Lombok: 모든 필드를 매개변수로 받는 생성자 자동 생성
public class Comment {
    @Id // 기본 키 (PK)
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    // 기본 키 자동 증가 전략 (DB의 auto_increment 사용)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    // 다대일 관계: 여러 댓글(Comment)이 하나의 게시글(Post)에 속할 수 있음
    @JoinColumn(name = "post_id", nullable = false)
    // FK 컬럼명: post_id, null 허용 x
    @JsonBackReference
    // 순환 참조 방지 (Post -> Comment -> Post 반복 구조 방지)
    @OnDelete(action = OnDeleteAction.CASCADE)
    // DB 레벨에서 게시글(Post) 삭제 시 해당 게시글의 댓글도 함께 삭제
    private User author;

    @Column(nullable = false)
    // 생성일시는 null 불가
    private LocalDateTime createdAt;
    private LocalDateTime updatedAt;    // 수정일시는 null 허용 (처음엔 없을 수 있음)

    private Integer likeCount = 0;
    // 좋아요 수 (기본값 0)

    @OneToMany(mappedBy = "commnet", cascade = CascadeType.ALL, orphanRemoval = true)
    // CommentLike 엔티티와 1:N 관계
    // mappedBy = "comment" -> CommentLike 엔티티의 comment 필드가 FK 소유
    // cascade = CascadeType.ALL -> 댓글 삭제 시 연결된 좋아요(CommentLike)도 자동 삭제
    // orphanRemoval = true -> 관계 끊어진 좋아요 엔티티도 DB에서 삭제
    private Set<CommentLike> likes = new HashSet<>();

    @PrePersist
    // 엔티티가 DB에 처음 저장되기 전 실행되는 콜백 메서드
    public void prePersist() {
        this.createdAt = LocalDateTime.now();
        // 저장 시 자동으로 현재 시간을 생성일시로 기록
    }

    @PreUpdate
    // 엔티티가 업데이트되기 전 실행되는 콜백 메서드
    public void preUpdate() {
        this.updatedAt = LocalDateTime.now();
        // 수정할 때 자동으로 현재 시간을 수정일시로 기록
    }
}



추가 해설
1. 관계 매핑
@ManyToOne :
댓글은 하나의 게시글(Post)와 하나의 사용자(User)에 속한자
@OneToMany :
댓글은 여러 개의 좋아요(CommentLike)를 가질 수 있다.

2. 삭제 연관 동작
@OnDelete(action = OnDeleteAction.CASCADE) :
DB레벨에서 게시글/사용자가 삭제되면 관련 댓글도 자동 삭제된다.
(Hibernate 전용 기능)

3. JSON 순환 참조 방지
@JsonBackReference
Post <-> comment 간 양방향 참조 시 무한 루프 방지
(Post에서 Comment는 직렬화하지만, Comment에서 Post는 직렬화하지 않는다)

4. 자동 시간 기록
@PrePersist: 최초 저장 시 createdAt 자동 기록
@PreUpdate: 수정 시 updatedAt 자동 갱신

5. 좋아요 수 관리
likeCount는 성능 최적화를 위해 카운트 필드로 유지
likes 는 실제 좋아요 엔티티(CommentLike)와의 관계를 관리



@ManyToOne(fetch = FetchType.LAZY)

는 JPA 엔티티 연관관계 설정에서 쓰이는 어노테이션입니다

1. @ManyToOne
N:1 관계를 의미합니다
댓글(Comment) -> 게시글(Post)은 여러 댓글이 하나의 게시글에 속함
댓글(Comment) -> 사용자(User) 도 여러 댓글을 한 사용자가 작성함

즉,
Comment 입장에서는 Post, User 는 부모   이고,   Comment 가 외래 키(FK)를 가집니다.


2. fetch = FetchType.LAZY
지연 로딩(Lazy Loading) 전략을 의미합니다.
JPA 기본값은 @ManyToOne 관계에서 EAGER(즉시 로딩) 인데, 성능 최적화를 위해
LAZY로 바꿔 주는 경우가 있습니다.


동작 차이
EAGER (즉시 로딩)
댓글을 DB에서 조회할 때, 관련된 Post나 User 도 함께 즉시 가져옵니다
->
필요 없을 때도 불필요한 조인 발생
->
성능 저하


LAZY (지연 로딩)
댓글을 가져올 때는 post_id 또는 user_id 값(FK)만 먼저 가져옴
->
실제 Post 객체나 User 객체가 필요할 때 (예: comment.getPost().getTitile())
그 순간 DB에서 추가 조회 발생

예시
Comment comment = commentRepository.findById(1L).get();

// 아직 Post는 조회하지 않음 (프록시 객체)
System.out.println(comment.getId());

// 여기서 Post 데이터 필요 -> DB 쿼리 실행
System.out.println(comment.getPost().getTitle());

@ManyToOne(fetch = FetchType.LAZY)
Comment와 Post/ User 간에 N:1 관계를 설정하고,
관련 엔티티는 필요할 때만 DB에서 조회하도록 지연 로딩 전략을 적용한다는 뜻입니다.



@JoinColumn(name = "post_id", nullable = false)

1. @JoinColumn
JPA에서 외래 키(FK) 컬럼을 매핑할 때 사용하는 어노테이션입니다.
지금은 Comment -> Post 관계에서 사용되고 있어요.
즉, 댓글(Comment) 테이블이 post_id 라는 외래 키 컬럼을 가지고 게시글(Post) 테이블과 연결된다는 뜻입니다

2. name = "post_id"
DB 테이블에 실제로 생성될 외래 키 컬럼 이름을 지정합니다.
따라서 comment 테이블에는 다음과 같은 컬럼이 생겨요


sql
id              BIGINT(PK)
post_id         BIGINT(FK)  -> post.id
user_id         BIGINT(FK)  -> user.id
content         TEXT


3. nullable = false
이 외래 키 컬럼(post_id)이 NULL이 될 수 없다  는 의미입니다.
즉, 반드시 댓글은 게시글에 속해야 한다는 규칙을 DB레벨 에서 강제 합니다

만약 nullable = true 였다면
댓글이 게시글 없이도 저장될 수 있음 -> 논리적으로 맞지 않음
따라서 댓글은 항상 어떤 게시글에 소속되어야 하므로 false 가 맞습니다


정리
@JoinColumn(name = "post_id", nullable = false)
comment 테이블에 post_id 라는 외래 키 컬럼을 만들고,
 그 값은 반드시 존재해야 하며,
 post 테이블의 id와 연결된다.



@JsonBackReference
@JsonBackReference는 Jackson 라이브러리(JSON 직렬화/역직렬화 라이브러리) 에서 사용하는 어노테이션입니다.

1.문제 상황 : 순환 참조
엔티티 간에 양방향 관계가 있으면, JSON으로 변환할 때 무한 루프 문제가 생깁니다.


예시)
java
class Post {
    List<Comment> comments;
}

class Comment {
    Post post;
}

Post 안에 Comment 리스트 있음
Comment 안에 다시 Post 있음

이 상태에서 Post -> JSON 직렬화하면?
Post -> Comment -> 다시 Post -> 또 Comment ... 무한 반복






JPA
cascade = CascadeType.REMOVE 와의 차이

cascade = CascadeType.REMOVE
JPA 가 엔티티 삭제 시 영속성 컨텍스트를 순회하면서 자식 엔티티를 하나씩 삭제
(DELETE 쿼리 여러 번 실행)
애플리케이션 레벨에서 동작

@OnDelete(action = CASCADE)
DB에서 직접 ON DELETE CASCADE 동작을 실행
부모 삭제 시 DB가 알아서 자식 레코드를 지워줌
SQL 쿼리 실행 효율 up  (대량 데이터일 때 성능 차이 큼)


현재 코드 예시
@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = "post_id", nullable = false)
@JsonBackReference
@OnDelete(action = OnDeleteAction.CASCADE)
private Post post;

게시글(Post) 삭제 시, 그 게시글에 달린 댓글(Comment)들이 DB레벨에서 자동으로 같이 삭제됨


SQL 관점 예시
Hibernate가 테이블 생성 시 다음처럼 제약 조건이 붙습니다

sql
ALTER TABLE comment
ADD CONSTRAINT fk_post
FOREIGN KEY (post_id)
REFERENCES post(id)
ON DELETE CASCADE;


정리
@OnDelete(action = OnDeleteAction.CASCADE)
DB에서 부모 삭제 시 자식도 함께 삭제되도록 설정하는 것
JPA의 CascadeType.REMOVE 와 달리, DB가 직접 처리해서 더 효율적



@Column(nullable = false, columnDefinition = "TEXT")
이 필드는 NULL 불가이고, DB에선 TEXT 타입 컬럼으로 생성된다.
댓글 내용은 반드시 존재해야 하며, 글자 수에 제한 없이 저장 가능하다



mappedBy = "comment"
양방향 매핑에서 "주인(Owner)"이 누구인지를 지정합니다
"comment"는 commentLike 엔티티 안에 있는 필드명을 가리킵니다


cascade = CascadeType.ALL
부모(Comment)에 대한 영속성 작업이 자식(CommentLike)에게도 전파됩니다.

예시:
commentRespository.save(comment) -> likes 안에 있는 CommentLike 들도 자동 저장

commentRepository.remove(comment) -> 관련된 CommentLike 들도 자동 삭제


orphanRemoval = true
고아 객체 제거 가능
부모 엔티티와의 관계가 끊어진 자식 엔티티를 자동 삭제합니다

java
comment.getLikes().remove(like);
like 엔티티는 더 이상 어떤 댓글에도 속하지 않음 -> DB에서 자동 삭제

@OneToMany(mappedBy = "comment", cascade = CascadeType.ALL, orphanRemoval = true)
private Set<CommentLikes> likes = new HashSet<>();

하나의 댓글에는 여러 개의 좋아요가 있을 수 있다.
외래 키 (comment_id)는 CommentLike 엔티티에서 관리한다
댓글 저장/삭제 시 좋아요도 같이 저장/삭제 된다.
댓글과의 연결이 끊긴 좋아요(고아 엔티티)는 DB에서 자동 삭제된다.

->
댓글이 부모, 좋아요가 자식. 댓글이 저장/ 삭제되면 좋아요도 같이 처리되고, 댓글과 연결이 끊긴 좋아요는
자동으로 지워진다.



private Set<CommentLike> likes
자료형 Set<CommentLike>
댓글(Comment)과 연결된 좋아요(CommentLike) 객체들을 담는 컬렉션 필드입니다.
List 대신 Set을 사용
-> 중복된 좋아요를 허용하지 않겠다는 의도
(예: 같은 사용자가 같은 댓글에 여러 번 좋아요 누르는 것을 방지할 수 있음)


= new HashSet<>()
초기화 코드
JPA에서는 컬렉션을 null로 두지 않고 보통 빈 컬렉션으로 초기화해둡니다
null이면 NullPointerException 위험
빈 HashSet 이면 안전하게   .add()    .remove() 가능


동작방식(Comment <-> CommentLike 관계)
@OneToMany(mappedBy = "comment", cascade = CascadeType.ALL, orphanRemove = true)
와 연결되어 있기 때문에,
likes 컬렉션은 해당 댓글에 달린 모든 좋아요 목록을 담습니다

예시 코드
Comment comment = new Comment();
CommentLike like1 = new CommentLike(user1, comment);
CommentLike like2 = new CommentLike(user2, comment);

comment.getLikes().add(like1);
comment.getLikes().add(like2);

likes 안에는 [like1, like2] 가 들어 있다.
DB 저장 시 comment_id 외래 키를 통해 comment_like 테이블에 매핑됨



왜 Set을 쓸까??
->
Set은 중복 방지 + 순서 중요하지 않음
좋아요는 "몇 명이 눌렀는지"만 중요하지, 순서는 중요하지 않음 -> Set 적절함
만약 "좋아요를 누른 순서" 같은 것이 필요하다면 List를 썼을 것




정리
private Set<CommentLike> likes = new HashSet<>();
댓글이 가진 "좋아요"들을 저장하는 컬렉션 필드
중복을 허용하지 않고, 처음부터 빈 HashSet으로 초기화해서 안전하게 사용





@PrePersist
1.@PrePersist란?
jpa Entity Lifecycle Callback(생명주기 콜백) 어노테이션 중 하나입니다
엔티티가 처음 persist()   (즉, DB에 저장) 되기 직전에 자동으로 실행되는 메서드에 붙입니다

2. 현재 코드에서의 의미
java

@PrePersist
public void proPersist() {
    this.createdAt = LocalDateTime.now();
}

Comment 객체가 처음 저장 되지 직전에 실행됨
createdAt 필드에 현재 시간을 자동으로 넣어줌

즉, 개발자가 comment.setCreatedAt(...) 하지 않아도, DB 저장할 때 생성 시간이 자동 기록됩니다.

4. 동작예시
Comment comment = new Comment();
comment.setContent("좋은 글이네요")
commentRepository.save(comment);

실제로 save() 할 때
1.
jpa가 comment를 저장하기 직전 -> @PrePersist 실행
2.
createdAt = LocalDateTime.now() 자동세팅
3.
Db에 INSERT 실행


정리
->
@Prepersist 는 엔티티가 처음 저장되기 직전에 자동 실행되는 콜백으로,
현재 코드에서는 댓글 작성 시간을 자동으로 기록하는 데 사용된다.




public void prePersist() {
    this.createdAt = LocalDateTime.now();
}

public void
반환값 없음, JPA가 자동으로 호출

prePersist()
이름은 자유롭게 지을 수 있지만, 보통 의미를 직관적으로 나타냄
(persist 직전 실행)

{ this.createdAt = LocalDateTime.now(); }
엔티티 필드 createdAt에 현재 시간 저장


2.동작 방식
Comment 엔티티 객체를 새로 생성

java
Comment comment = new Comment();
comment.setContent("좋은 글이에요");


commentRepository.save(comment) 호출 -> jpa가 db에 insert 준비

insert 직전에 prePersist() 호출

createdAt 필드가 자동으로 현재 시간 LocalDateTime.now() 으로 세팅

그 값과 함께 DB에 INSERT

개발자가 따로 setCreatedAt() 하지 않아도 자동으로 작성 시간이 기록됨



예시
Comment comment = new Comment();
comment.setContent("안녕하세요!");
commentRepository.save(comment);

System.out.println(comment.getCreatedAt());
// -> 2025-09-18T17:00:12.345 (자동으로 현재 시각)

정리
prePersist() 는 엔티티가 DB에 저장되기 직전에 실행되는 메서드
여기서는 댓글 작성 시간(createdAt)을 자동으로 기록하도록 함
수동으로 시간을 설정할 필요 없이, 엔티티 저장 시점이 항상 정확하게 기록됨



@PreUpdate 란?
JPA 엔티티 생명주기 콜백(Lifecycle Callback) 어노테이션 중 하나입니다
엔티티가 DB에서 UPDATE 되기 직전에 자동으로 호출되는 메서드에 붙입니다



현재 코드에서의 의미
@PreUpdate
public void preUpdate() {
    this.updatedAt = LocalDateTime.now();
}

Comment 엔티티가 수정되어 DB에 반영되기 직전에 실행됨
updatedAt 필드에 현재 시간을 자동으로 넣어줌
즉, 개발자가 따로 comment.setUpdatedAt(...) 하지 않아도, 댓글 수정 시간이 자동으로 기록


동작 예시
Comment comment = commentRepoistory.findById(1L).get();
comment.setContent("내용 수정!");
commentRepository.save(comment);

실제로 UPDATE 될 때
1. JPA가 엔티티 변경 감지(Dirty Checking)
2. DB에 UPDATE 실행 직전에 preUpdate() 호출
3. updatedAt = LocalDateTime.now() 세팅
4. 변경된 값과 함께 DB UPDATE 수행





4. @PrePersist 와의 차이

@PrePersist
엔티티 저장 전
createdAt

@PreUpdate
엔티티 수정 전
updatedAt

보통 둘을 함께 사용
생성 시간과 수정 시간을 자동 관리 가능



@PreUpdate
엔티티가 수정되어 DB에 반영되기 직전에 실행되는 콜백
여기서는 댓글 수정 시간(updatedAt)을 자동으로 기록하도록 함





public void preUpdate() {
    this.updatedAt = LocalDateTime.now();
}

public void
반환값 없음, jpa가 자동으로 호출

preUpdate()
메서드 이름은 자유롭게 지을 수 있지만, 보통 의미를 직관적으로 나타냄(업데이트 직전 실행)

{   this.updatedAt = LocalDateTime.now();   }
엔티티 필드 updatedAt 에 현재 시간 저장



동작 방식
1. DB에서 이미 존재하는 Comment 엔티티 객체를 조회

Comment comment = commentRepository.findById(1L).get();


2. 엔티티 필드 수정
comment.setContent("내용 수정!");

3. jpa가 dirty checking 을 통해 변경 감지

4. DB에 UPDATE SQL 실행 직전에 preUpdate() 호출

5. updatedAt 필드가 자동으로 현재 시간 (LocalDateTime.now())으로 세팅

6. 변경된 값과 함께 DB UPDATE 실행



예시
Comment comment = commentRepository.findById(1L).get();
comment.setContent("좋아요 추가!");
commentRepository.save(comment);

System.out.println(comment.getUpdatedAt());
// -> 2025-09-18T17:10:45.123 (자동으로 현재 시각)



@PrePersist
실행시점         엔티티 저장 전
필드 예시        createdAt



@PreUpdate
실행 시점           엔티티 수정 전
필드 예시           updatedAt



@PrePersist
생성 시간 자동 기록

@PreUpdate
수정 시간 자동 기록



PreUpdate() 메서드
엔티티가 수정되어 DB에 반영되기 직전에 자동 실행
updatedAt 필드를 현재 시각으로 자동 업데이트
개발자가 따로 수정 시간을 설정할 필요 없이 항상 최신 값 유지





@OneToMany(mappedBy = "comment", cascade = CascadeType.ALL, orphanRemoval = true)
private Set<CommentLike> likes = new HashSet<>();


@OneToMany(mappedBy = "comment", ...)
1:N 관계 매핑
하나의 댓글(Comment)에는 여러 개의 좋아요(CommentLike)가 달릴 수 있음
mappedBy = "comment" -> 외래 키(FK)는 CommentLike 엔티티가 관리한다는 뜻
(즉, CommentLike 안에 @ManyToOne private Comment comment; 가 있어야한다)

-> 이쪽(Comment)은 읽기 전용(주인이 아님), 외래 키는 자식 테이블(CommentLike)에서 가짐


cascade = CascadeType.ALL
부모(Comment)에 대한 모든 영속성 작업이 자식(CommentLike)에도 전파됨
댓글 저장 시 -> 좋아요도 같이 저장
댓글 삭제 시 -> 좋아요도 같이 삭제
댓글 업데이트 시 -> 좋아요도 같이 반영



orphanRemoval = true
부모와의 관계가 끊어진 자식 엔티티(고아 객체)는 DB에서도 자동 삭제됨

comment.getLikes().remove(like);
해당 like는 DB에서도 자동 삭제





private Set<CommentLike> likes = new HashSet<>();
댓글에 달린 좋아요들을 저장하는 컬렉션 필드

Set
중복 허용 하지 않음 (같은 사람이 같은 댓글에 여러 번 좋아요 못 누르게 할 수 있음)

new HashSet<>()
->
NullPointerException 방지를 위해 처음부터 빈 컬렉션으로 초기화



정리 해석
이 코드는 댓글(Comment)이 가진 좋아요(CommentLike)목록을 관리하는 필드이다
하나의 댓글에는 여러 좋아요가 달릴 수 있고, 댓글이 저장,수정,삭제 될 때 좋아요도 함께 처리된다.
또한 댓글과의 연결이 끊긴 좋아요는 DB에서도 자동으로 삭제된다.
좋아요는 중복을 허용하지 않으며, 기본적으로 빈 집합으로 시작한다.