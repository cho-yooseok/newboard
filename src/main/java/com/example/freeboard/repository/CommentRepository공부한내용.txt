CommentRepository는 일반 사용자 기능(조회, 카운트)과 관리자 기능(전체 조회, 검색) 사용자 삭제 기능을
모두 포함한 댓글 전용 DB 접근 계층입니다

주석
@Repository // 스프링에게 이 인터페이스가 "DB 접근 계층(Repository)"임을 알림
public interface CommentRepository extends JpaRepository<Comment, Long> {
    // Comment 엔티티를 관리하는 JPA Repository
    // JpaRepository<Comment, Long> -> (엔티티, PK 타입)


    // 특정 게시글의 모든 댓글 조회
    List<Comment> findByPostId(Long postId);
    // postId 를 조건으로 모든 댓글 리스트를 반환
    // SQL : SELECT * FROM comments WHERE post_id = ?


    // 특정 게시글의 댓글 수 카운트
    Long countByPostId(Long postId);
    // postId 에 해당하는 댓글 개수 반환
    // SQL : SELECT COUNT(*) FROM comments WHERE post_id = ?


    // 관리자 기능
    // 관리자 페이지에서 댓글과 작성자, 게시글까지 한번에 페이징 조회
    @Query(value = "SELECT c FROM Comment c JOIN FETCH c.author JOIN FETCH c.post",
            countQuery = "SELECT COUNT(c) FROM Comment c ")
    Page<Comment> findAllForAdmin(Pageable pageable);
    // JOIN FETCH: 지연로딩(LAZY) 대신 댓글 + 작성자 + 게시글을 한번에 불러옴 ( N + 1 문제 방지)
    // Page<Comment>: 페이징된 댓글 목록 반환
    // countQuery: 전체 개수를 세기 위한 별도 쿼리

    // 관리자 검색기능



}





@Query(
    value = "SELECT c FROM Comment c JOIN FETCH c.author JOIN FETCH c.post",
    countQuery = "SELECT COUNT(c) FROM Comment c"
)



@Query
Spring Data JPA 에서 직접 JPQL 쿼리를 작성할 때 사용
메서드 실행 시 여기 적힌 쿼리가 실행됨


value
sql
SELECT c FROM Comment c
JOIN FETCH c.author
JOIN FETCH c.post

Comment 엔티티를 조회하면서, 작성자(author), 게시글(post)도 한 번에 즉시 로딩(FETCH) 해옴
JOIN FETCH 를 쓰면 지연 로딩(LAZY)으로 인한 N+1 문제를 방지 가능


countQuery
SELECT COUNT(c) FROM Comment c
페이징 처리를 위해 전체 댓글 개수를 세는 별도의 쿼리
value 쿼리처럼 JOIN을 포함하지 않고 단순히 개수만 반환

한 줄 해석
댓글(Comment)을 작성자(author), 게시글(post)와 함께 조인해서 조회하고, 페이징을 위한 전체 개수는 따로 세어온다.