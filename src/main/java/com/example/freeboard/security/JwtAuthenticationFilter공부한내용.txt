주석
/**
JwtAuthenticationFilter
Spring Security의 OncePerRequestFilter를 상속받은 커스텀 필터 클래스.
매 요청마다 실행되며, HTTP 요청 헤더에 포함된 JWT 토큰을 검증하고,
유효한 경우 Spring Security의 인증 컨텍스트(SecurityContext)에 사용자 정보를 설정한다.
**/

@Component // 스프링 빈으로 등록되어 Security Filter Chain에서 사용된다.
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    // 로그 출력을 위한 Logger 인스턴스
    private static final Logger logger = LoggerFanctory.getLogger(JwtAuthenticationFilter.class);

    // JWT 토큰 생성, 검증, 파싱을 담당하는 유틸리티 클래스
    private final JwtTokenProvider tokenProvider;

    // 데이터베이스에서 사용자 정보를 조회하기 위한 서비스
    private final CustomUserDetailsService customUserDetailsService;

    // 생성자 주입(Autowired를 통해 스프링이 의존성을 주입)
    @Autowired
    public JwtAuthenticationFilter(JwtTokenProvider tokenProvier, CustomUserDetailsService customUserDetailsService) {
        this.tokenProvider = tokenProvider;
        this.customUserDetailsService = customUserDetailsService;
    }

    /**
    doFilterInternal
    실제 필터 로직이 수행되는 메서드
    요청(request)에서 JWT를 추출하고, 검증 후 인증 정보를 설정한다.
    **/
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {
        try {
            // 1. 요청 헤더에서 JWT 추출
            String jwt = getJwtFromRequest(request);

            // 2. JWT가 존재하고 유효한 경우
            if(StingUtils.hasText(jwt) && tokenProvider.validateToken(jwt)) {

                // 3. JWT에서 username(또는 email) 추출
                String username = tokenProvider.getUsernameFromJWT(jwt);

                // 4. DB 또는 UserDetailsService에서 해당 사용자 정보 조회
                UserDetails userDetails = customUserDetailsService.loadUserByUsername(username);

                // 5. 스프링 시큐리티의 인증 객체 생성 (비밀번호는 null로 설정)
                UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(
                    userDetails, null, userDetails.getAuthorities());

                // 6. 요청 정보를 Authentication 객체에 추가 (IP, 세션 등)
                authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));

                // 7. SecurityContext에 인증 정보 저장 (현재 스레드의 보안 컨텍스트에 설정)
                SecurityContextHolder.getContext().setAuthentication(authentication);
            }

        } catch (Exception ex) {
            // JWT 검증 실패 시 예외 로그 출력(인증이 실패하더라도 요청은 계속 진행됨)
            logger.error("보안 컨텍스트에 사용자 인증을 설정할 수 없습니다.". ex);
        }

        //  6. 다음 필터로 요청 전달 (다음 시큐리티 필터 또는 컨트롤러로 이동)
        filterChain.doFilter(request, response);
    }

    /**
    getJwtFromRequest
    HTTP 요청 헤더에서 Authorization 값을 추출하고,
    "Bearer" 접두어가 있는 경우 실제 토큰 부분만 반환한다.

    예시:
    Authorization: Bearer eyJhgcfdfkjdkfdfcvdf
    **/
    private String getJwtFromRequest(HttpServletRequest request) {
        // Authorization 헤더 값 가져오기
        String bearerToken = request.getHeader("Authorization");

        // "Bearer"로 시작하는 경우 실제 JWT 부분만 잘라서 반환
        if (StringUtils.hasText(bearerToken) && bearerToken.startsWith("Bearer")) {
            return bearerToken.substring(7);    // "Bearer" 이후의 문자열만 추출
        }

        // 없거나 잘못된 경우 null 반환
        return null;
    }
}




전체 동작 흐름 해설
1. 요청이 들어옴
JwtAuthenticationFilter 가 실행됨(OncePerRequestFilter 를 상속했으므로 요청마다 한 번더 실행됨)

2. 헤더에서 JWT 추출
Authentication: Bearer {JWT} 형식에서 토큰만 분리

3. 토큰 검증
JwtTokenProvider.validateToken(jwt) 호출 (만료 여부, 위조 여부 확인)

4. 사용자 정보 로드
토큰에서 username 추출 후 DB에서 UserDetails 가져옴

5. SecurityCotext에 인증 객체 저장
이후 컨트롤러(@RestController)에서 @AuthenticaitonPrincipal 또는 SecurityContextHolder를 통해
현재 로그인한 사용자 정보 접근 가능.


요약하면, 이 클래스는 모든 요청에 대해 JWT 토큰을 검사하고,
유효하면 Spring Security 인증 컨텍스트에 사용자 정보를 등록하는 역할을 합니다











동작 요약
1. HTTP 요청이 들어오면 이 필터가 실행됨 (OncePerRequestFilter는 요청당 1회 실행 보장)

2. Authorization 헤더에서 "Bearer {JWT}" 형식의 토큰을 추출

3. JwtTokenProvider 를 통해 토큰 검증 (validateToken())

4. 유효하면 토큰에서 사용자명 (username) 추출

5. DB에서 해당 사용자 정보를 로드(CustomUserDetailsService)

6. UsernamePasswordAuthenticationToken 생성 후 보안 컨텍스트에 등록

7. 이후 요청은 인증된 사용자로 처리 가능 (컨트롤러에서 @AuthenticationPrincipal 사용 가능)





@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {
}


@Component
스프링이 이 클래스를 자동으로 빈(Bean)으로 등록하도록 하는 애너테이션입니다
즉, 개발자가 따로 @Bean 설정을 하지 않아도, 스프링이 애플리케이션 실행 시 이 클래스를 스캔해서 스프링 컨테이너에 등록합니다
이로써 의존성 주입 @Autowired 등을 통해 다른 클래스에서 이 필터를 사용할 수 있게 됩니다


public class JwtAuthenticationFilter
JwtAuthenticationFilter는 클래스이름입니다
보통 Jwt(Json Web Token)를 이용해 사용자의 인증정보를 검사하는 보안필터(Security Fitler)역할을 합니다


extends OncePerRequestFilter
OncePerRequestFilter 는 스프링 시큐리티(Spring Security)가 제공하는 추상 클래스입니다
이름 그대로 "요청당 한 번만 실행되는 필터"를 의미합니다
이 클래스를 상속받으면,
매 요청(Request)마다 한 번만 실행되는 doFilterInternal() 메서드를 오버라이드(override)해서 필터 로직을 구현할 수 있습니다


이 코드는 JWT 인증을 처리하기 위한 커스텀 필터 클래스를 정의하는 선언부입니다
스프링이 자동으로 관리하고, 각 HTTP 요청마다 한 번씩 실행되어 JWT 토큰을 검증하는 역할을 하게 됩니다




private static final Logger logger = LoggerFactory.getLogger(JwtAuthenticationFilter.class);


private
접근 제어자로
이 logger 변수는 이 클래스(JwtAuthenticationFilter) 내부에서만 접근 가능합니다


static final
static: 클래스 수준에서 공유되는 변수(객체를 여러 개 만들어도 딱 하나만 존재)
final: 한 번 초기화 되면 변경할 수 없음 (상수처럼 동작)

즉, logger는 공유되고 수정 불가능한 고정된 로거(Logger)입니다


Logger
Logger는 로그를 기록하는 객체타입니다


